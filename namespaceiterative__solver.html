<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iterative-solver: iterative_solver Module Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iterative-solver
   &#160;<span id="projectnumber">.</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceiterative__solver.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Types</a> &#124;
<a href="#func-members">Functions/Subroutines</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">iterative_solver Module Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>IterativeSolver Fortran binding.  
<a href="namespaceiterative__solver.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Types</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceiterative__solver_1_1mpi__init.html">mpi_init</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">interface &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="interfaceiterative__solver_1_1mpi__rank__global.html">mpi_rank_global</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions/Subroutines</h2></td></tr>
<tr class="memitem:a2890fe920d167483bcac382af12afe5d"><td class="memItemLeft" align="right" valign="top">integer(kind=<a class="el" href="namespaceiterative__solver.html#a8e7b0afa0169579bd571c1aac764d4e8">mpicomm_kind</a>) function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a2890fe920d167483bcac382af12afe5d">mpicomm_compute</a> ()</td></tr>
<tr class="separator:a2890fe920d167483bcac382af12afe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508258aa021cc2d872fba06bd1cff849"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a508258aa021cc2d872fba06bd1cff849">set_mpicomm_compute</a> (comm)</td></tr>
<tr class="separator:a508258aa021cc2d872fba06bd1cff849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeac19cec453d5df15b17ea1b0f157fb"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#aeeac19cec453d5df15b17ea1b0f157fb">iterative_solver_linear_eigensystem_initialize</a> (nq, nroot, thresh, thresh_value, hermitian, verbosity, pname, mpicomm, algorithm, range, options)</td></tr>
<tr class="memdesc:aeeac19cec453d5df15b17ea1b0f157fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the lowest eigensolutions of a matrix. The default algorithm is Davidson's method, i.e. preconditioned Lanczos. Example of simplest use:  <a href="namespaceiterative__solver.html#aeeac19cec453d5df15b17ea1b0f157fb">More...</a><br /></td></tr>
<tr class="separator:aeeac19cec453d5df15b17ea1b0f157fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c4bfefb260bc5df5c34a84a24a3138"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a69c4bfefb260bc5df5c34a84a24a3138">iterative_solver_linear_equations_initialize</a> (nq, nroot, rhs, augmented_hessian, thresh, thresh_value, hermitian, verbosity, pname, mpicomm, algorithm, range, options)</td></tr>
<tr class="memdesc:a69c4bfefb260bc5df5c34a84a24a3138"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the solutions of linear equation systems using a generalisation of Davidson's method, i.e. preconditioned Lanczos Example of simplest use:  <a href="namespaceiterative__solver.html#a69c4bfefb260bc5df5c34a84a24a3138">More...</a><br /></td></tr>
<tr class="separator:a69c4bfefb260bc5df5c34a84a24a3138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ec1c6cf65a2f9d40f2035e7ca0b77ec"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a7ec1c6cf65a2f9d40f2035e7ca0b77ec">iterative_solver_optimize_initialize</a> (nq, thresh, verbosity, minimize, pname, mpicomm, algorithm, range, thresh_value, options)</td></tr>
<tr class="memdesc:a7ec1c6cf65a2f9d40f2035e7ca0b77ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimization through the L-BFGS or related methods. Example of simplest use:  <a href="namespaceiterative__solver.html#a7ec1c6cf65a2f9d40f2035e7ca0b77ec">More...</a><br /></td></tr>
<tr class="separator:a7ec1c6cf65a2f9d40f2035e7ca0b77ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0193308603bbbe44226e4745032d12f7"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a0193308603bbbe44226e4745032d12f7">iterative_solver_diis_initialize</a> (nq, thresh, verbosity, pname, mpicomm, algorithm, range, options)</td></tr>
<tr class="memdesc:a0193308603bbbe44226e4745032d12f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Accelerated convergence of non-linear equations through the DIIS or related methods. Example of simplest use:  <a href="namespaceiterative__solver.html#a0193308603bbbe44226e4745032d12f7">More...</a><br /></td></tr>
<tr class="separator:a0193308603bbbe44226e4745032d12f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a3d04d226f8315ed2a57baa5d78304"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a40a3d04d226f8315ed2a57baa5d78304">iterative_solver_finalize</a></td></tr>
<tr class="memdesc:a40a3d04d226f8315ed2a57baa5d78304"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the iterative solver.  <a href="namespaceiterative__solver.html#a40a3d04d226f8315ed2a57baa5d78304">More...</a><br /></td></tr>
<tr class="separator:a40a3d04d226f8315ed2a57baa5d78304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70258968c6cc6e822b9008afcccd8a79"><td class="memItemLeft" align="right" valign="top">integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a70258968c6cc6e822b9008afcccd8a79">iterative_solver_add_vector</a> (parameters, action, synchronize, value)</td></tr>
<tr class="memdesc:a70258968c6cc6e822b9008afcccd8a79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take, typically, a current solution and residual, add it to the expansion set, and return new solution. In the context of Lanczos-like linear methods, the input will be a current expansion vector and the result of acting on it with the matrix, and the output will be a new expansion vector.  <a href="namespaceiterative__solver.html#a70258968c6cc6e822b9008afcccd8a79">More...</a><br /></td></tr>
<tr class="separator:a70258968c6cc6e822b9008afcccd8a79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03f7586355d8dab8557e6cde9fc0078b"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a03f7586355d8dab8557e6cde9fc0078b">iterative_solver_solution</a> (roots, parameters, action, synchronize)</td></tr>
<tr class="memdesc:a03f7586355d8dab8557e6cde9fc0078b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the current solution.  <a href="namespaceiterative__solver.html#a03f7586355d8dab8557e6cde9fc0078b">More...</a><br /></td></tr>
<tr class="separator:a03f7586355d8dab8557e6cde9fc0078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad609af42ab2050142d98f5ca57522322"><td class="memItemLeft" align="right" valign="top">function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#ad609af42ab2050142d98f5ca57522322">iterative_solver_end_iteration</a> (solution, residual, synchronize)</td></tr>
<tr class="memdesc:ad609af42ab2050142d98f5ca57522322"><td class="mdescLeft">&#160;</td><td class="mdescRight">For most methods, does nothing; for Optimize it is required. Also write progress to standard output.  <a href="namespaceiterative__solver.html#ad609af42ab2050142d98f5ca57522322">More...</a><br /></td></tr>
<tr class="separator:ad609af42ab2050142d98f5ca57522322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa924c3a27ae8d7dfb5f6946c9ab55222"><td class="memItemLeft" align="right" valign="top">integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#aa924c3a27ae8d7dfb5f6946c9ab55222">iterative_solver_add_p</a> (nP, offsets, indices, coefficients, pp, parameters, action, fproc, synchronize)</td></tr>
<tr class="memdesc:aa924c3a27ae8d7dfb5f6946c9ab55222"><td class="mdescLeft">&#160;</td><td class="mdescRight">add P-space vectors to the expansion set, and return new solution.  <a href="namespaceiterative__solver.html#aa924c3a27ae8d7dfb5f6946c9ab55222">More...</a><br /></td></tr>
<tr class="separator:aa924c3a27ae8d7dfb5f6946c9ab55222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5165398f200e5ac77b1a80676108cc29"><td class="memItemLeft" align="right" valign="top">integer function, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a5165398f200e5ac77b1a80676108cc29">iterative_solver_suggest_p</a> (solution, residual, indices, threshold)</td></tr>
<tr class="memdesc:a5165398f200e5ac77b1a80676108cc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take an existing solution and its residual, and suggest P vectors.  <a href="namespaceiterative__solver.html#a5165398f200e5ac77b1a80676108cc29">More...</a><br /></td></tr>
<tr class="separator:a5165398f200e5ac77b1a80676108cc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8771b451fe4f3381b22d6a64d96f23bd"><td class="memItemLeft" align="right" valign="top">double precision function, dimension(:), allocatable, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a8771b451fe4f3381b22d6a64d96f23bd">iterative_solver_errors</a> ()</td></tr>
<tr class="memdesc:a8771b451fe4f3381b22d6a64d96f23bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">errors for each root  <a href="namespaceiterative__solver.html#a8771b451fe4f3381b22d6a64d96f23bd">More...</a><br /></td></tr>
<tr class="separator:a8771b451fe4f3381b22d6a64d96f23bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad8d58daf37b4b32e1f85046611ece6"><td class="memItemLeft" align="right" valign="top">double precision function, dimension(m_nroot), public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#afad8d58daf37b4b32e1f85046611ece6">iterative_solver_eigenvalues</a> ()</td></tr>
<tr class="memdesc:afad8d58daf37b4b32e1f85046611ece6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the lowest eigenvalues of the reduced problem, for the number of roots sought.  <a href="namespaceiterative__solver.html#afad8d58daf37b4b32e1f85046611ece6">More...</a><br /></td></tr>
<tr class="separator:afad8d58daf37b4b32e1f85046611ece6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11e3d198ebd7872c9ed08cbbdf9dd012"><td class="memItemLeft" align="right" valign="top">double precision function, dimension(working_set_size), public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a11e3d198ebd7872c9ed08cbbdf9dd012">iterative_solver_working_set_eigenvalues</a> (working_set_size)</td></tr>
<tr class="memdesc:a11e3d198ebd7872c9ed08cbbdf9dd012"><td class="mdescLeft">&#160;</td><td class="mdescRight">the eigenvalues of the reduced problem, for the number of roots in working set (not yet converged).  <a href="namespaceiterative__solver.html#a11e3d198ebd7872c9ed08cbbdf9dd012">More...</a><br /></td></tr>
<tr class="separator:a11e3d198ebd7872c9ed08cbbdf9dd012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c16d60f650492b99c576d20b2af5d15"><td class="memItemLeft" align="right" valign="top">subroutine, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a1c16d60f650492b99c576d20b2af5d15">iterative_solver_solve</a> (parameters, actions, <a class="el" href="structiterative__solver__problem_1_1problem.html">problem</a>, generate_initial_guess, max_iter)</td></tr>
<tr class="separator:a1c16d60f650492b99c576d20b2af5d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a8e7b0afa0169579bd571c1aac764d4e8"><td class="memItemLeft" align="right" valign="top">integer, parameter, public&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceiterative__solver.html#a8e7b0afa0169579bd571c1aac764d4e8">mpicomm_kind</a> = KIND(c_int64_t)</td></tr>
<tr class="separator:a8e7b0afa0169579bd571c1aac764d4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>IterativeSolver Fortran binding. </p>
</div><h2 class="groupheader">Function/Subroutine Documentation</h2>
<a id="aa924c3a27ae8d7dfb5f6946c9ab55222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa924c3a27ae8d7dfb5f6946c9ab55222">&#9670;&nbsp;</a></span>iterative_solver_add_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer function, public iterative_solver::iterative_solver_add_p </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(0:np), intent(in)&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(offsets(np)), intent(in)&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(offsets(np)), intent(in)&#160;</td>
          <td class="paramname"><em>coefficients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(*), intent(in)&#160;</td>
          <td class="paramname"><em>pp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(:, :), intent(inout)&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(:, :), intent(inout)&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">external&#160;</td>
          <td class="paramname"><em>fproc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>synchronize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>add P-space vectors to the expansion set, and return new solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nP</td><td>the number of P-space vectors to add </td></tr>
    <tr><td class="paramname">offsets</td><td>specifies the start point in indices and coefficients that defines each vector. </td></tr>
    <tr><td class="paramname">indices</td><td>Index in the full space of a contribution to a new P vector </td></tr>
    <tr><td class="paramname">coefficients</td><td>Value of a contribution to a new P vector </td></tr>
    <tr><td class="paramname">pp</td><td>The P-P block of the matrix, dimensioned (number of existing P + nP, nP) </td></tr>
    <tr><td class="paramname">parameters</td><td>On input, the current solution or expansion vector. On exit, the interpolated solution vector. </td></tr>
    <tr><td class="paramname">action</td><td>On input, the residual for parameters (non-linear), or action of matrix on parameters (linear). </td></tr>
    <tr><td class="paramname">fproc</td><td></td></tr>
    <tr><td class="paramname">synchronize</td><td>Whether to synchronize any distributed storage of parameters and action before return. Unnecessary if the client preconditioner is diagonal, but otherwise should be done. The default is the safe .TRUE. but can be .FALSE. if appropriate. On exit, the expected (non-linear) or actual (linear) residual of the interpolated parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a70258968c6cc6e822b9008afcccd8a79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70258968c6cc6e822b9008afcccd8a79">&#9670;&nbsp;</a></span>iterative_solver_add_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer function, public iterative_solver::iterative_solver_add_vector </td>
          <td>(</td>
          <td class="paramtype">double precision, dimension(..), intent(inout), target&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(..), intent(inout), target&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>synchronize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, optional&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take, typically, a current solution and residual, add it to the expansion set, and return new solution. In the context of Lanczos-like linear methods, the input will be a current expansion vector and the result of acting on it with the matrix, and the output will be a new expansion vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>On input, the current solution or expansion vector. On exit, the interpolated solution vector. </td></tr>
    <tr><td class="paramname">action</td><td>On input, the residual for parameters (non-linear), or action of matrix on parameters (linear). On exit, the expected (non-linear) or actual (linear) residual of the interpolated parameters. </td></tr>
    <tr><td class="paramname">synchronize</td><td>Whether to synchronize any distributed storage of parameters and action before return. Unnecessary if the client preconditioner is diagonal, but otherwise should be done. The default is the safe .TRUE. but can be .FALSE. if appropriate. </td></tr>
    <tr><td class="paramname">value</td><td>The value of the objective function for parameters. Used only in non-linear optimization. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the size of the working set for the next iteration. The client is expected to apply any preconditioner to this number of vectors in action before the subsequent call to Iterative_Solver_End_Iteration(). In non-linear optimisation, the special value -1 can also be returned, indicating that preconditioning should not be carried out on action. </dd></dl>

</div>
</div>
<a id="a0193308603bbbe44226e4745032d12f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0193308603bbbe44226e4745032d12f7">&#9670;&nbsp;</a></span>iterative_solver_diis_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iterative_solver::iterative_solver_diis_initialize </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in), optional&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len = *), intent(in), optional&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in), optional&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len = *), intent(in), optional&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(2), intent(inout), optional&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(*), intent(in), optional&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Accelerated convergence of non-linear equations through the DIIS or related methods. Example of simplest use: </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">PROGRAM</span> diis_example</div>
<div class="line">  <span class="keywordtype">USE </span><a class="code" href="namespaceiterative__solver.html">iterative_solver</a></div>
<div class="line">  <span class="keywordtype">IMPLICIT NONE</span></div>
<div class="line">  <span class="keywordtype">INTEGER</span>, <span class="keywordtype">PARAMETER</span> :: n = 1000</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n, n)</span> :: m</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n)</span> :: c, g</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span> :: e</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION(1)</span> :: error</div>
<div class="line">  <span class="keywordtype">INTEGER</span> :: i, j</div>
<div class="line">  <span class="keywordtype">LOGICAL</span> :: converged</div>
<div class="line">  print *, <span class="stringliteral">&#39;Fortran binding of IterativeSolver::DIIS&#39;</span></div>
<div class="line">  m = 1; <span class="keywordflow">DO</span> i = 1, n; m(i, i) = 3 * i;</div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_diis_initialize(n, thresh = 1d-11, verbosity = 1)</div>
<div class="line">  c = 0; c(1) = 1</div>
<div class="line">  <span class="keywordflow">DO</span> i = 1, n</div>
<div class="line">    c = c / sqrt(dot_product(c, c))</div>
<div class="line">    g = matmul(m, c)</div>
<div class="line">    e = dot_product(c, g)</div>
<div class="line">    g = g - e * c</div>
<div class="line">    <span class="keywordflow">IF</span> (iterative_solver_add_vector(c, g)) &amp;</div>
<div class="line">      c = c - g / ([(m(j, j), j = 1, n)] - e + 1d-15)</div>
<div class="line">    converged = iterative_solver_end_iteration(c, g, error)</div>
<div class="line">    <span class="keywordflow">IF</span> (converged) <span class="keywordflow">EXIT</span></div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  print *, <span class="stringliteral">&#39;error =&#39;</span>, error</div>
<div class="line">  c = c / sqrt(dot_product(c, c))</div>
<div class="line">  print *, <span class="stringliteral">&#39;solution &#39;</span>, c(1 : min(n, 10))</div>
<div class="line">  print *, <span class="stringliteral">&#39;expectation &#39;</span>, e</div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_finalize</div>
<div class="line"><span class="keyword">END PROGRAM </span>diis_example</div>
<div class="ttc" id="anamespaceiterative__solver_html"><div class="ttname"><a href="namespaceiterative__solver.html">iterative_solver</a></div><div class="ttdoc">IterativeSolver Fortran binding.</div><div class="ttdef"><b>Definition:</b> IterativeSolverF.F90:2</div></div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nq</td><td>dimension of parameter space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh</td><td>convergence threshold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>how much to print. Default is zero, which prints nothing except errors. One gives a single progress-report line each iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pname</td><td>Profiler object name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>Profiler communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algorithm</td><td>algorithm, eg DIIS </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range</td><td>distributed array local range start and end indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>key1=value1, key2=value1,... to specify arbitrary options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afad8d58daf37b4b32e1f85046611ece6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad8d58daf37b4b32e1f85046611ece6">&#9670;&nbsp;</a></span>iterative_solver_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double precision function, dimension(m_nroot), public iterative_solver::iterative_solver_eigenvalues</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the lowest eigenvalues of the reduced problem, for the number of roots sought. </p>

</div>
</div>
<a id="ad609af42ab2050142d98f5ca57522322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad609af42ab2050142d98f5ca57522322">&#9670;&nbsp;</a></span>iterative_solver_end_iteration()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function, public iterative_solver::iterative_solver_end_iteration </td>
          <td>(</td>
          <td class="paramtype">double precision, dimension(..), intent(inout), target&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(..), intent(inout), target&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>synchronize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For most methods, does nothing; for Optimize it is required. Also write progress to standard output. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>On exit, the new vectors targeting roots in the working set. </td></tr>
    <tr><td class="paramname">residual</td><td>On entry, the preconditioned residual. On exit, undefined. </td></tr>
    <tr><td class="paramname">synchronize</td><td>Whether to synchronize any distributed storage of parameters before return. The default is the safe .TRUE. but can be .FALSE. if appropriate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the working set </dd></dl>

</div>
</div>
<a id="a8771b451fe4f3381b22d6a64d96f23bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8771b451fe4f3381b22d6a64d96f23bd">&#9670;&nbsp;</a></span>iterative_solver_errors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double precision function, dimension(:), allocatable, public iterative_solver::iterative_solver_errors</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>errors for each root </p>

</div>
</div>
<a id="a40a3d04d226f8315ed2a57baa5d78304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a3d04d226f8315ed2a57baa5d78304">&#9670;&nbsp;</a></span>iterative_solver_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iterative_solver::iterative_solver_finalize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Terminate the iterative solver. </p>

</div>
</div>
<a id="aeeac19cec453d5df15b17ea1b0f157fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeac19cec453d5df15b17ea1b0f157fb">&#9670;&nbsp;</a></span>iterative_solver_linear_eigensystem_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iterative_solver::iterative_solver_linear_eigensystem_initialize </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>thresh_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in), optional&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len = *), intent(in), optional&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer(kind = <a class="el" href="namespaceiterative__solver.html#a8e7b0afa0169579bd571c1aac764d4e8">mpicomm_kind</a>), intent(in), optional&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len = *), intent(in), optional&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(2), intent(inout), optional&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(*), intent(in), optional&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the lowest eigensolutions of a matrix. The default algorithm is Davidson's method, i.e. preconditioned Lanczos. Example of simplest use: </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">PROGRAM</span> linear_eigensystem_example</div>
<div class="line">  <span class="keywordtype">USE </span><a class="code" href="namespaceiterative__solver.html">iterative_solver</a></div>
<div class="line">  <span class="keyword">interface</span></div>
<div class="line">    <span class="keyword">subroutine </span><a class="code" href="interfaceiterative__solver_1_1mpi__init.html">mpi_init</a>() bind (C, name = &#39;mpi_init&#39;)</div>
<div class="line">    <span class="keyword">end subroutine </span><a class="code" href="interfaceiterative__solver_1_1mpi__init.html">mpi_init</a></div>
<div class="line">    <span class="keyword">subroutine </span>mpi_finalize() bind (C, name = &#39;mpi_finalize&#39;)</div>
<div class="line">    <span class="keyword">end subroutine </span>mpi_finalize</div>
<div class="line">    <span class="comment">!    function mpi_comm_global() BIND (C, name = &#39;mpi_comm_global&#39;)</span></div>
<div class="line">    <span class="comment">!      use iso_c_binding, only: c_int64_t</span></div>
<div class="line">    <span class="comment">!      integer(c_int64_t) mpi_comm_global</span></div>
<div class="line">    <span class="comment">!    end function mpi_comm_global</span></div>
<div class="line">  <span class="keyword">end interface</span></div>
<div class="line">  <span class="keywordtype">INTEGER</span>, <span class="keywordtype">PARAMETER</span> :: n = 6, nroot = 3</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n, n)</span> :: m</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n, nroot)</span> :: c, g</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (nroot)</span> :: e, error</div>
<div class="line">  <span class="keywordtype">INTEGER</span> :: i, j, root</div>
<div class="line">  <span class="keywordtype">LOGICAL</span> :: converged</div>
<div class="line">  print *, <span class="stringliteral">&#39;Fortran binding of IterativeSolver&#39;</span></div>
<div class="line">  m = 1; <span class="keywordflow">DO</span> i = 1, n; m(i, i) = 3 * i;</div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_linear_eigensystem_initialize(n, nroot, thresh = 1d-7, verbosity = 1)</div>
<div class="line">  c = 0; <span class="keywordflow">DO</span> i = 1, nroot; c(i, i) = 1;</div>
<div class="line"><span class="keywordflow">  ENDDO</span></div>
<div class="line">  <span class="keywordflow">DO</span> i = 1, n</div>
<div class="line">    g = matmul(m, c)</div>
<div class="line">    <span class="keywordflow">IF</span> (iterative_solver_add_vector(c, g, e)) <span class="keywordflow">THEN</span></div>
<div class="line">      e = iterative_solver_eigenvalues()</div>
<div class="line">      <span class="keywordflow">DO</span> root = 1, nroot</div>
<div class="line">        <span class="keywordflow">DO</span> j = 1, n</div>
<div class="line">          c(j, root) = c(j, root) - g(j, root) / (m(j, j) - e(root) + 1e-15)</div>
<div class="line"><span class="keywordflow">        END DO</span></div>
<div class="line"><span class="keywordflow">      END DO</span></div>
<div class="line"><span class="keywordflow">    END IF</span></div>
<div class="line">    converged = iterative_solver_end_iteration(c, g, error)</div>
<div class="line">    <span class="keywordflow">IF</span> (converged) <span class="keywordflow">EXIT</span></div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  print *, <span class="stringliteral">&#39;error =&#39;</span>, error, <span class="stringliteral">&#39; eigenvalue =&#39;</span>, e</div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_print_statistics</div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_finalize</div>
<div class="line">  <span class="keyword">CALL </span>mpi_finalize</div>
<div class="line"><span class="keyword">END PROGRAM </span>linear_eigensystem_example</div>
<div class="ttc" id="ainterfaceiterative__solver_1_1mpi__init_html"><div class="ttname"><a href="interfaceiterative__solver_1_1mpi__init.html">iterative_solver::mpi_init</a></div><div class="ttdef"><b>Definition:</b> IterativeSolverF.F90:45</div></div>
</div><!-- fragment --><p> Example including use of P space: </p><div class="fragment"><div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">MODULE</span> pspace</div>
<div class="line">  use, <span class="keywordtype">INTRINSIC</span> :: iso_c_binding</div>
<div class="line">  <span class="keywordtype">INTEGER</span>, <span class="keywordtype">PARAMETER</span> :: n = 60, nroot = 3, np = 20</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n, n)</span> :: m</div>
<div class="line">  <span class="keywordtype">INTEGER</span>, <span class="keywordtype">DIMENSION(nP)</span> :: indices</div>
<div class="line">  <span class="keywordtype">INTEGER</span> :: i, j, root, offset</div>
<div class="line">  <span class="keyword">CONTAINS</span></div>
<div class="line">    <span class="keyword">subroutine </span>apply_on_p(p, g, update_size, ranges) <span class="keyword">BIND(C)</span></div>
<div class="line">      <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION(*)</span>, <span class="keywordtype">INTENT(inout)</span> :: g</div>
<div class="line">      <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION(nP,nroot)</span>, <span class="keywordtype">INTENT(inout)</span> :: p</div>
<div class="line">      <span class="keywordtype">INTEGER</span>, <span class="keywordtype">DIMENSION(*)</span>, <span class="keywordtype">INTENT(in)</span> :: ranges</div>
<div class="line">      <span class="keywordtype">INTEGER(c_size_t)</span>, <span class="keywordtype">INTENT(in)</span>, <span class="keywordtype">VALUE</span> :: update_size</div>
<div class="line">      <span class="keywordtype">INTEGER</span> :: irange, root, range</div>
<div class="line">      <span class="comment">!write(*,*) &quot;APPLY_ON_P was called!!!&quot;</span></div>
<div class="line">      irange = 1</div>
<div class="line">      <span class="keywordflow">DO</span> root = 1, update_size</div>
<div class="line">        offset = ranges(irange)</div>
<div class="line">        <span class="comment">!range = ranges(irange+1) - ranges(irange)</span></div>
<div class="line">        <span class="comment">!if (rank == 1) then</span></div>
<div class="line">        <span class="comment">!  write(*,*) &quot;gg[&quot;,root,&quot;] : &quot;, g((root-1)*n+1:(root-1)*n+range)</span></div>
<div class="line">        <span class="comment">!  write(*,*) &quot;p[&quot;,root,&quot;] : &quot;, p(:,root)</span></div>
<div class="line">        <span class="comment">!end if</span></div>
<div class="line">        <span class="keywordflow">DO</span> i = 1, np</div>
<div class="line">          <span class="keywordflow">DO</span> j = ranges(irange)+1, ranges(irange+1)</div>
<div class="line">            <span class="comment">!! To be used if action vector is fully stored on each process</span></div>
<div class="line">            g((root-1)*n+j-offset) = g((root-1)*n+j-offset) + m(j, indices(i)) * p(i,root)</div>
<div class="line">            <span class="comment">!! To be used if action vector is distributed across processes</span></div>
<div class="line">            <span class="comment">!g((root-1)*range+j-offset) = g((root-1)*range+j-offset) + m(j, indices(i)) * p(i,root)</span></div>
<div class="line"><span class="keywordflow">          END DO</span></div>
<div class="line"><span class="keywordflow">        END DO</span></div>
<div class="line">        <span class="comment">!if (rank == 1) then</span></div>
<div class="line">        <span class="comment">!  write(*,*) &quot;gg[&quot;,root,&quot;] after : &quot;, g((root-1)*n+1:(root-1)*n+range)</span></div>
<div class="line">        <span class="comment">!end if</span></div>
<div class="line">        irange = irange + 2</div>
<div class="line"><span class="keywordflow">      END DO</span></div>
<div class="line">    <span class="keyword">end subroutine </span>apply_on_p</div>
<div class="line"><span class="keyword">END MODULE </span>pspace</div>
<div class="line"> </div>
<div class="line"><span class="keyword">PROGRAM</span> linear_eigensystem_example</div>
<div class="line">  <span class="keywordtype">USE </span>pspace</div>
<div class="line">  <span class="keywordtype">USE </span><a class="code" href="namespaceiterative__solver.html">iterative_solver</a></div>
<div class="line">  <span class="keywordtype">USE </span>profilerf</div>
<div class="line">  include <span class="stringliteral">&#39;mpif.h&#39;</span></div>
<div class="line"> </div>
<div class="line">  <span class="comment">!INTEGER, PARAMETER :: n = 20, nroot = 3, nP = 10</span></div>
<div class="line">  <span class="comment">!DOUBLE PRECISION, DIMENSION (n, n) :: m</span></div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n, nroot)</span> :: c, g</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION(nP, nroot)</span> :: p</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (nroot)</span> :: e</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">ALLOCATABLE</span>, <span class="keywordtype">DIMENSION(:)</span> :: we</div>
<div class="line">  <span class="keywordtype">INTEGER</span>, <span class="keywordtype">DIMENSION(0 : nP)</span> :: offsets</div>
<div class="line">  <span class="comment">!INTEGER, DIMENSION(nP) :: indices</span></div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION(nP)</span> :: coefficients</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION(nP, nP)</span> :: pp</div>
<div class="line">  <span class="comment">!INTEGER :: i, j, root</span></div>
<div class="line">  <span class="keywordtype">LOGICAL</span> :: update</div>
<div class="line">  <span class="keywordtype">INTEGER</span> :: nwork, alloc_stat</div>
<div class="line">  <span class="keywordtype">INTEGER</span> :: rank, comm_size, ierr</div>
<div class="line">  <span class="keywordtype">INTEGER</span> :: roots(nroot)</div>
<div class="line">  <span class="keywordtype">TYPE</span>(Profiler) :: prof</div>
<div class="line">  rank = 0</div>
<div class="line">  <span class="keyword">call </span><a class="code" href="interfaceiterative__solver_1_1mpi__init.html">mpi_init</a>(ierr)</div>
<div class="line">  <span class="keyword">call </span>mpi_comm_rank(mpi_comm_world, rank, ierr)</div>
<div class="line">  <span class="keyword">call </span>mpi_comm_size(mpi_comm_world, comm_size, ierr)</div>
<div class="line">  <span class="keywordflow">if</span> (rank == 0) <span class="keywordflow">then</span></div>
<div class="line">    print *, <span class="stringliteral">&#39;Fortran binding of IterativeSolver&#39;</span></div>
<div class="line">    print *, <span class="stringliteral">&#39;Using parallel version&#39;</span></div>
<div class="line"><span class="keywordflow">  endif</span></div>
<div class="line">  m = 1</div>
<div class="line">  <span class="keywordflow">DO</span> i = 1, n</div>
<div class="line">    m(i, i) = 3 * i</div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  prof=profiler(<span class="stringliteral">&#39;Eigensystem_Example_P&#39;</span>, 1, 0)</div>
<div class="line">  <span class="keywordflow">if</span> (rank == 0) <span class="keywordflow">then</span></div>
<div class="line">    <span class="keyword">WRITE</span> (6, *) <span class="stringliteral">&#39;P-space=&#39;</span>, np, <span class="stringliteral">&#39;, dimension=&#39;</span>, n, <span class="stringliteral">&#39;, roots=&#39;</span>, nroot</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_linear_eigensystem_initialize(n, nroot, thresh = 1d-8, thresh_value = 1d-14, hermitian=.true., &amp;</div>
<div class="line">                                              verbosity = 1, pname = <span class="stringliteral">&#39;Eigensystem_Example_P&#39;</span>, mpicomm = mpi_comm_world)</div>
<div class="line">  offsets(0) = 0</div>
<div class="line">  <span class="keywordflow">DO</span> i = 1, np</div>
<div class="line">    offsets(i) = i</div>
<div class="line">    indices(i) = i <span class="comment">! the first nP components</span></div>
<div class="line">    coefficients(i) = 1</div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  <span class="keywordflow">DO</span> i = 1, np</div>
<div class="line">    <span class="keywordflow">DO</span> j = 1, np</div>
<div class="line">      pp(i, j) = m(indices(i), indices(j))</div>
<div class="line"><span class="keywordflow">    END DO</span></div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  nwork =  iterative_solver_add_p(np, offsets, indices, coefficients, pp, c, g, fproc=apply_on_p)</div>
<div class="line">  <span class="comment">!g = 0.0d0</span></div>
<div class="line">  <span class="keywordflow">DO</span> iter = 1, 100</div>
<div class="line"><span class="comment">!    IF (rank == 0) THEN</span></div>
<div class="line"><span class="comment">!      PRINT *, &#39;ITERATION #&#39;, iter</span></div>
<div class="line"><span class="comment">!      PRINT *, &#39;nwork after Add_Vector():&#39;, nwork</span></div>
<div class="line"><span class="comment">!    END IF</span></div>
<div class="line">    <span class="keyword">allocate</span>(we(nwork), stat=alloc_stat)</div>
<div class="line">    we = iterative_solver_working_set_eigenvalues(nwork)</div>
<div class="line"><span class="comment">!    IF (rank == 0) THEN</span></div>
<div class="line"><span class="comment">!      PRINT *, &#39;Working set roots after Add_Vector():&#39;, we</span></div>
<div class="line"><span class="comment">!    END IF</span></div>
<div class="line">    <span class="keywordflow">DO</span> root = 1, nwork</div>
<div class="line">      <span class="keywordflow">DO</span> j = 1, n</div>
<div class="line">        g(j, root) = - g(j, root) * 1.0d0 / (m(j, j) - we(root) + 1e-15)</div>
<div class="line"><span class="keywordflow">      END DO</span></div>
<div class="line"><span class="keywordflow">    END DO</span></div>
<div class="line">    <span class="keyword">deallocate</span>(we)</div>
<div class="line">    nwork = iterative_solver_end_iteration(c, g)</div>
<div class="line">    <span class="keywordflow">IF</span> (nwork == 0) <span class="keywordflow">THEN</span></div>
<div class="line">      <span class="keywordflow">EXIT</span></div>
<div class="line"><span class="keywordflow">    END IF</span></div>
<div class="line">    <span class="keyword">allocate</span>(we(nwork), stat=alloc_stat)</div>
<div class="line">    we = iterative_solver_working_set_eigenvalues(nwork)</div>
<div class="line"><span class="comment">!    IF (rank == 0) THEN</span></div>
<div class="line"><span class="comment">!      PRINT *, &#39;Working set roots after End_Iteration():&#39;, we</span></div>
<div class="line"><span class="comment">!    END IF</span></div>
<div class="line">    <span class="keyword">deallocate</span>(we)</div>
<div class="line">    g = matmul(m, c)</div>
<div class="line">    nwork = iterative_solver_add_vector(c, g)</div>
<div class="line">    <span class="keywordflow">IF</span> (nwork == 0) <span class="keywordflow">THEN</span></div>
<div class="line">      <span class="keywordflow">EXIT</span></div>
<div class="line"><span class="keywordflow">    END IF</span></div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  <span class="keyword">allocate</span>(we(nroot), stat=alloc_stat)</div>
<div class="line">  we = iterative_solver_eigenvalues()</div>
<div class="line">  <span class="keywordflow">IF</span> (rank == 0) <span class="keywordflow">THEN</span></div>
<div class="line">    print *, <span class="stringliteral">&#39;Converged roots:&#39;</span>, we</div>
<div class="line"><span class="keywordflow">  END IF</span></div>
<div class="line">  <span class="keyword">deallocate</span>(we)</div>
<div class="line">  <span class="keywordflow">DO</span> root = 1, nroot</div>
<div class="line">    roots(root) = root</div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  <span class="keywordflow">if</span> (rank == 0) <span class="keywordflow">then</span></div>
<div class="line">    <span class="keyword">write</span>(*,*) <span class="stringliteral">&quot;Solution vector before the call to Solution(): &quot;</span>, c(:,1)</div>
<div class="line">    <span class="keyword">write</span>(*,*) <span class="stringliteral">&quot;Residual before the call to Solution: &quot;</span>, g(:,1)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_solution(roots, c, g)</div>
<div class="line">  <span class="keywordflow">if</span> (rank == 0) <span class="keywordflow">then</span></div>
<div class="line">    <span class="keyword">write</span>(*,*) <span class="stringliteral">&quot;Solution vector after the call to Solution(): &quot;</span>, c(:,1)</div>
<div class="line">    <span class="keyword">write</span>(*,*) <span class="stringliteral">&quot;Residual after the call to Solution: &quot;</span>, g(:,1)</div>
<div class="line"><span class="keywordflow">  end if</span></div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_print_statistics</div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_finalize</div>
<div class="line">  <span class="keyword">call </span>prof%print(6)</div>
<div class="line">  <span class="keyword">call </span>prof%destroy()</div>
<div class="line">  <span class="keyword">call </span>mpi_finalize(ierr)</div>
<div class="line"><span class="keyword">END PROGRAM </span>linear_eigensystem_example</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nq</td><td>dimension of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nroot</td><td>number of eigensolutions desired </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh</td><td>Convergence threshold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh_value</td><td>Value convergence threshold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hermitian</td><td>Whether the underlying kernel is hermitian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>Print level One gives a single progress-report line each iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pname</td><td>Profiler object name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>MPI communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algorithm</td><td>algorithm, eg Davidson </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range</td><td>distributed array local range start and end indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>key1=value1, key2=value1,... to specify arbitrary options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a69c4bfefb260bc5df5c34a84a24a3138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69c4bfefb260bc5df5c34a84a24a3138">&#9670;&nbsp;</a></span>iterative_solver_linear_equations_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iterative_solver::iterative_solver_linear_equations_initialize </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(nq, nroot), intent(in)&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>augmented_hessian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>thresh_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in), optional&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len = *), intent(in), optional&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in), optional&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len = *), intent(in), optional&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(2), intent(inout), optional&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(*), intent(in), optional&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the solutions of linear equation systems using a generalisation of Davidson's method, i.e. preconditioned Lanczos Example of simplest use: </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">PROGRAM</span> linear_equations_example</div>
<div class="line">  <span class="keywordtype">USE </span><a class="code" href="namespaceiterative__solver.html">iterative_solver</a></div>
<div class="line">  <span class="keywordtype">IMPLICIT NONE</span></div>
<div class="line">  <span class="keywordtype">INTEGER</span>, <span class="keywordtype">PARAMETER</span> :: n = 30, nroot = 2</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">PARAMETER</span> :: alpha = 300</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION(5)</span>, <span class="keywordtype">PARAMETER</span> :: augmented_hessian_factors = [0.0_8, .001_8, .01_8, .1_8, 1.0_8]</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n, n)</span> :: m</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n, nroot)</span> :: c, g, rhs</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (nroot)</span> :: error</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span> :: augmented_hessian</div>
<div class="line">  <span class="keywordtype">INTEGER</span> :: i, j, root, iaug, nwork</div>
<div class="line">  <span class="keywordtype">LOGICAL</span> :: converged</div>
<div class="line">  print *, <span class="stringliteral">&#39;Fortran binding of IterativeSolver&#39;</span></div>
<div class="line">  <span class="keyword">call </span><a class="code" href="interfaceiterative__solver_1_1mpi__init.html">mpi_init</a></div>
<div class="line">  <span class="keywordflow">DO</span> i = 1, n; m(i, i) = alpha * i + 2 * i - 2; <span class="keywordflow">DO</span> j = 1, n; <span class="keywordflow">IF</span> (i.NE.j) m(i, j) = i + j - 2;</div>
<div class="line">  <span class="keyword">END </span>do;</div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  <span class="keywordflow">DO</span> i = 1, nroot; <span class="keywordflow">DO</span> j = 1, n; rhs(j, i) = 1 / dble(j + i - 1);</div>
<div class="line">  <span class="keyword">END </span>do;</div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  nwork = nroot</div>
<div class="line">  <span class="keywordflow">DO</span> iaug = 1, <span class="keyword">SIZE</span>(augmented_hessian_factors)</div>
<div class="line">    augmented_hessian = augmented_hessian_factors(iaug)</div>
<div class="line">    print *, <span class="stringliteral">&#39;solve linear system with augmented hessian factor &#39;</span>, augmented_hessian</div>
<div class="line">    <span class="keyword">CALL </span>iterative_solver_linear_equations_initialize(n, nroot, rhs, augmented_hessian, thresh = 1d-11, verbosity = 1)</div>
<div class="line">    c = 0; <span class="keywordflow">DO</span> i = 1, nroot; c(i, i) = 1;</div>
<div class="line"><span class="keywordflow">    ENDDO</span></div>
<div class="line">    <span class="keywordflow">DO</span> i = 1, n</div>
<div class="line">      g = matmul(m, c)</div>
<div class="line">      nwork = iterative_solver_add_vector(c, g)</div>
<div class="line">        <span class="keywordflow">DO</span> root = 1, nwork</div>
<div class="line">          <span class="keywordflow">DO</span> j = 1, n</div>
<div class="line">            c(j, root) = c(j, root) - g(j, root) / m(j, j)</div>
<div class="line"><span class="keywordflow">          END DO</span></div>
<div class="line"><span class="keywordflow">        END DO</span></div>
<div class="line">      nwork = iterative_solver_end_iteration(c, g)</div>
<div class="line">      <span class="keywordflow">IF</span> (nwork .LE. 0) <span class="keywordflow">EXIT</span></div>
<div class="line"><span class="keywordflow">    END DO</span></div>
<div class="line">    print *, <span class="stringliteral">&#39;error =&#39;</span>, iterative_solver_errors()</div>
<div class="line">    <span class="keywordflow">DO</span> i = 1, nroot</div>
<div class="line">      print *, <span class="stringliteral">&#39;solution &#39;</span>, c(1 : min(n, 10), i)</div>
<div class="line"><span class="keywordflow">    END DO</span></div>
<div class="line">    <span class="keyword">Call </span>iterative_solver_print_statistics</div>
<div class="line">    <span class="keyword">CALL </span>iterative_solver_finalize</div>
<div class="line"><span class="keywordflow">  ENDDO</span></div>
<div class="line">  <span class="keyword">CALL </span>mpi_finalize</div>
<div class="line"><span class="keyword">END PROGRAM </span>linear_equations_example</div>
</div><!-- fragment --><p> Example including use of P space: include LinearEquationsExampleF-Pspace.F90 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nq</td><td>dimension of matrix </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">nroot</td><td>number of eigensolutions desired </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>the constant right-hand-side of each equation system </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">augmented_hessian</td><td>If zero, solve the inhomogeneous equations unmodified. If 1, solve instead the augmented hessian problem. Other values scale the augmented hessian damping. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh</td><td>convergence threshold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh_value</td><td>value convergence threshold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">hermitian</td><td>whether the underlying kernel is hermitian </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>how much to print. Default is zero, which prints nothing except errors. One gives a single progress-report line each iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pname</td><td>Profiler object name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>MPI communicator </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range</td><td>distributed array local range start and end indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>key1=value1, key2=value1,... to specify arbitrary options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7ec1c6cf65a2f9d40f2035e7ca0b77ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ec1c6cf65a2f9d40f2035e7ca0b77ec">&#9670;&nbsp;</a></span>iterative_solver_optimize_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iterative_solver::iterative_solver_optimize_initialize </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>nq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in), optional&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>minimize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(len = *), intent(in), optional&#160;</td>
          <td class="paramname"><em>pname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, intent(in), optional&#160;</td>
          <td class="paramname"><em>mpicomm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(*), intent(in), optional&#160;</td>
          <td class="paramname"><em>algorithm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(2), intent(inout), optional&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>thresh_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">character(*), intent(in), optional&#160;</td>
          <td class="paramname"><em>options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Optimization through the L-BFGS or related methods. Example of simplest use: </p>
<div class="fragment"><div class="line"> </div>
<div class="line"><span class="keyword">PROGRAM</span> quasinewton_example</div>
<div class="line">  <span class="keywordtype">USE </span><a class="code" href="namespaceiterative__solver.html">iterative_solver</a></div>
<div class="line">  <span class="keywordtype">IMPLICIT NONE</span></div>
<div class="line">  <span class="keywordtype">INTEGER</span>, <span class="keywordtype">PARAMETER</span> :: n = 2</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n, n)</span> :: m</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span>, <span class="keywordtype">DIMENSION (n)</span> :: c, g</div>
<div class="line">  <span class="keywordtype">DOUBLE PRECISION</span> :: e, e0</div>
<div class="line">  <span class="keywordtype">INTEGER</span> :: i, j</div>
<div class="line">  <span class="keywordtype">LOGICAL</span> :: converged</div>
<div class="line">  <span class="keywordtype">LOGICAL</span>, <span class="keywordtype">PARAMETER</span> :: forced = .false.</div>
<div class="line">  <span class="keyword">call </span><a class="code" href="interfaceiterative__solver_1_1mpi__init.html">mpi_init</a></div>
<div class="line">  print *, <span class="stringliteral">&#39;Fortran binding of IterativeSolver::IOptimize&#39;</span></div>
<div class="line">  m = 1; <span class="keywordflow">DO</span> i = 1, n; m(i, i) = 3 * i;</div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_optimize_initialize(n, thresh = 1d-9, verbosity = 1, algorithm = <span class="stringliteral">&quot;BFGS&quot;</span>, options=<span class="stringliteral">&quot;max_size_qspace=7&quot;</span>)</div>
<div class="line">  c = 0; <span class="keywordflow">if</span> ( .not. forced) c(1) = 1</div>
<div class="line">  e0 = m(1, 1)</div>
<div class="line">  <span class="keywordflow">DO</span> i = 1, 30</div>
<div class="line">    g = matmul(m, c)</div>
<div class="line">    <span class="keywordflow">if</span> (forced) <span class="keywordflow">then</span></div>
<div class="line">      e = 0.5 * dot_product(c, g) - sum(c)</div>
<div class="line">      g = g - 1</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">      e = dot_product(c, g) / dot_product(c, c)</div>
<div class="line">      g = (g - e * c) / dot_product(c, c)</div>
<div class="line"><span class="keywordflow">    end if</span></div>
<div class="line">    <span class="keyword">write</span> (6, *) <span class="stringliteral">&#39;function value &#39;</span>, e</div>
<div class="line">    <span class="keyword">write</span> (6, *) <span class="stringliteral">&#39;c &#39;</span>, c</div>
<div class="line">    <span class="keyword">write</span> (6, *) <span class="stringliteral">&#39;g &#39;</span>, g</div>
<div class="line">    <span class="keywordflow">IF</span> (iterative_solver_add_vector(c, g, <span class="keywordtype">value</span> = e).gt.0) <span class="keywordflow">THEN</span></div>
<div class="line">      <span class="keywordflow">if</span> (forced) <span class="keywordflow">then</span></div>
<div class="line">        g = g / [(m(j, j), j = 1, n)]</div>
<div class="line">      <span class="keywordflow">else</span></div>
<div class="line">        g = g / ([(m(j, j), j = 1, n)] - e + 1d-15) &amp;</div>
<div class="line">          + (sum([(c(j) * g(j), j = 1, n)]) / sum([(c(j)**2, j = 1, n)])) * c &amp;</div>
<div class="line">            / ([(m(j, j), j = 1, n)] - e + 1d-15)</div>
<div class="line"><span class="keywordflow">      end if</span></div>
<div class="line"><span class="keywordflow">    END IF</span></div>
<div class="line">    converged = iterative_solver_end_iteration(c, g) .eq.0</div>
<div class="line">    <span class="keywordflow">IF</span> (converged) <span class="keywordflow">EXIT</span></div>
<div class="line"><span class="keywordflow">  END DO</span></div>
<div class="line">  <span class="keywordflow">if</span> (.not. forced) c = c / sqrt(dot_product(c, c))</div>
<div class="line">  print *, <span class="stringliteral">&#39;solution &#39;</span>, c(1:min(n, 10))</div>
<div class="line">  <span class="keyword">CALL </span>iterative_solver_finalize</div>
<div class="line">  <span class="keyword">call </span>mpi_finalize</div>
<div class="line"><span class="keyword">END PROGRAM </span>quasinewton_example</div>
</div><!-- fragment --> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nq</td><td>dimension of parameter space </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh</td><td>convergence threshold </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">verbosity</td><td>how much to print. Default is zero, which prints nothing except errors. One gives a single progress-report line each iteration. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">minimize</td><td>whether to minimize (default) or maximize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">pname</td><td>Profiler object name </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mpicomm</td><td>MPI communicator </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">algorithm</td><td>keyword specifying optimization algorithm </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">range</td><td>distributed array local range start and end indices </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">thresh_value</td><td>convergence threshold for function value </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">options</td><td>key1=value1, key2=value1,... to specify arbitrary options </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a03f7586355d8dab8557e6cde9fc0078b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03f7586355d8dab8557e6cde9fc0078b">&#9670;&nbsp;</a></span>iterative_solver_solution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iterative_solver::iterative_solver_solution </td>
          <td>(</td>
          <td class="paramtype">integer, dimension(:), intent(in)&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(..), intent(inout), target&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(..), intent(inout), target&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, intent(in), optional&#160;</td>
          <td class="paramname"><em>synchronize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate the current solution. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">roots</td><td>Array containing root indices </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">parameters</td><td>On exit, the solutions corresponding to roots. The second dimension must be at least as large as size(roots). </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">action</td><td>On exit, the residuals corresponding to roots. The second dimension must be at least as large as size(roots). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">synchronize</td><td>synchronize Whether to synchronize any distributed storage of parameters and action before return. Unnecessary if the client preconditioner is diagonal, but otherwise should be done. The default is the safe .TRUE. but can be .FALSE. if appropriate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1c16d60f650492b99c576d20b2af5d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c16d60f650492b99c576d20b2af5d15">&#9670;&nbsp;</a></span>iterative_solver_solve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iterative_solver::iterative_solver_solve </td>
          <td>(</td>
          <td class="paramtype">double precision, dimension(..), intent(inout), target&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(..), intent(inout), target&#160;</td>
          <td class="paramname"><em>actions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">class(problem_class), intent(in)&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">logical, optional&#160;</td>
          <td class="paramname"><em>generate_initial_guess</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, optional&#160;</td>
          <td class="paramname"><em>max_iter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5165398f200e5ac77b1a80676108cc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5165398f200e5ac77b1a80676108cc29">&#9670;&nbsp;</a></span>iterative_solver_suggest_p()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer function, public iterative_solver::iterative_solver_suggest_p </td>
          <td>(</td>
          <td class="paramtype">double precision, dimension(*), intent(in)&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, dimension(*), intent(in)&#160;</td>
          <td class="paramname"><em>residual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">integer, dimension(:), intent(inout)&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double precision, intent(in), optional&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take an existing solution and its residual, and suggest P vectors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">solution</td><td>On input, the current solution. </td></tr>
    <tr><td class="paramname">residual</td><td>On input, the residual for solution. </td></tr>
    <tr><td class="paramname">indices</td><td>On exit, the most important base vectors </td></tr>
    <tr><td class="paramname">threshold</td><td>IterativeSolver vectors whose predicted contribution is less than than this are not considered </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of vectors suggested. </dd></dl>

</div>
</div>
<a id="a11e3d198ebd7872c9ed08cbbdf9dd012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11e3d198ebd7872c9ed08cbbdf9dd012">&#9670;&nbsp;</a></span>iterative_solver_working_set_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double precision function, dimension(working_set_size), public iterative_solver::iterative_solver_working_set_eigenvalues </td>
          <td>(</td>
          <td class="paramtype">integer, intent(in)&#160;</td>
          <td class="paramname"><em>working_set_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the eigenvalues of the reduced problem, for the number of roots in working set (not yet converged). </p>

</div>
</div>
<a id="a2890fe920d167483bcac382af12afe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2890fe920d167483bcac382af12afe5d">&#9670;&nbsp;</a></span>mpicomm_compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer(kind = <a class="el" href="namespaceiterative__solver.html#a8e7b0afa0169579bd571c1aac764d4e8">mpicomm_kind</a>) function, public iterative_solver::mpicomm_compute</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a508258aa021cc2d872fba06bd1cff849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508258aa021cc2d872fba06bd1cff849">&#9670;&nbsp;</a></span>set_mpicomm_compute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">subroutine, public iterative_solver::set_mpicomm_compute </td>
          <td>(</td>
          <td class="paramtype">integer(kind = <a class="el" href="namespaceiterative__solver.html#a8e7b0afa0169579bd571c1aac764d4e8">mpicomm_kind</a>), intent(in)&#160;</td>
          <td class="paramname"><em>comm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a8e7b0afa0169579bd571c1aac764d4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7b0afa0169579bd571c1aac764d4e8">&#9670;&nbsp;</a></span>mpicomm_kind</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">integer, parameter, public iterative_solver::mpicomm_kind = KIND(c_int64_t)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceiterative__solver.html">iterative_solver</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
