<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iterative-solver: molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iterative-solver
   &#160;<span id="projectnumber">.</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>One specific implementation of <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title="Interface for a specific iterative solver, it can add special member functions or variables.">LinearEigensystem</a> using Davidson's algorithm with modifications to manage near linear dependencies, and consequent numerical noise, in candidate expansion vectors.  
 <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="LinearEigensystemDavidson_8h_source.html">LinearEigensystemDavidson.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson__inherit__graph.png" border="0" usemap="#amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_inherit__map" id="amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_inherit__map">
<area shape="rect" title="One specific implementation of LinearEigensystem using Davidson&#39;s algorithm with modifications to man..." alt="" coords="699,20,913,76"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html" title=" " alt="" coords="440,5,651,91"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title="Interface for a specific iterative solver, it can add special member functions or variables." alt="" coords="209,20,392,76"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers." alt="" coords="5,20,161,76"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson__coll__graph.png" border="0" usemap="#amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_coll__map" alt="Collaboration graph"/></div>
<map name="amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_coll__map" id="amolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson_3_01R_00_01Q_00_01P_01_4_coll__map">
<area shape="rect" title="One specific implementation of LinearEigensystem using Davidson&#39;s algorithm with modifications to man..." alt="" coords="839,91,1053,147"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html" title=" " alt="" coords="447,5,657,91"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title="Interface for a specific iterative solver, it can add special member functions or variables." alt="" coords="211,20,393,76"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers." alt="" coords="5,20,161,76"/>
<area shape="rect" href="classmolpro_1_1linalg_1_1itsolv_1_1detail_1_1DSpaceResetter.html" title=" " alt="" coords="443,115,661,157"/>
</map>
<center><span class="legend">[<a target="top" href="graph_legend.html">legend</a>]</span></center></div>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;class R, class Q = R, class P = std::map&lt;size_t, typename R::value_type&gt;&gt;<br />
class molpro::linalg::itsolv::LinearEigensystemDavidson&lt; R, Q, P &gt;</h3>

<p>One specific implementation of <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title="Interface for a specific iterative solver, it can add special member functions or variables.">LinearEigensystem</a> using Davidson's algorithm with modifications to manage near linear dependencies, and consequent numerical noise, in candidate expansion vectors. </p>
<p>TODO add more documentation and examples</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">R</td><td></td></tr>
    <tr><td class="paramname">Q</td><td></td></tr>
    <tr><td class="paramname">P</td><td></td></tr>
  </table>
  </dd>
</dl>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae0ec3d737bc94543b35dc4d0e3558470"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ae0ec3d737bc94543b35dc4d0e3558470">SolverTemplate</a> = <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, Q, P &gt;</td></tr>
<tr class="separator:ae0ec3d737bc94543b35dc4d0e3558470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a></td></tr>
<tr class="memitem:a027b41582a1fff9ebb679e6ae6e2fe5f inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> = typename R::value_type</td></tr>
<tr class="memdesc:a027b41582a1fff9ebb679e6ae6e2fe5f inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">The underlying type of elements of vectors.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">More...</a><br /></td></tr>
<tr class="separator:a027b41582a1fff9ebb679e6ae6e2fe5f inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce4d7778dab44edee1bea7075d7f227 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> = typename <a class="el" href="classmolpro_1_1linalg_1_1array_1_1ArrayHandler.html">array::ArrayHandler</a>&lt; R, Q &gt;::<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a></td></tr>
<tr class="separator:a4ce4d7778dab44edee1bea7075d7f227 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dcf15a66ef5c759d8a8a9a5616ce92 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a17dcf15a66ef5c759d8a8a9a5616ce92">value_type_abs</a> = typename <a class="el" href="classmolpro_1_1linalg_1_1array_1_1ArrayHandler.html">array::ArrayHandler</a>&lt; R, R &gt;::<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a17dcf15a66ef5c759d8a8a9a5616ce92">value_type_abs</a></td></tr>
<tr class="separator:a17dcf15a66ef5c759d8a8a9a5616ce92 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cc580bb3f1dfab899fa9b4cd68babf inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a83cc580bb3f1dfab899fa9b4cd68babf">VectorP</a> = std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> &gt;</td></tr>
<tr class="separator:a83cc580bb3f1dfab899fa9b4cd68babf inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64287edfda9bc2abbdafd958b6cfe682 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a64287edfda9bc2abbdafd958b6cfe682">fapply_on_p_type</a> = std::function&lt; void(const std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a83cc580bb3f1dfab899fa9b4cd68babf">VectorP</a> &gt; &amp;, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; P &gt; &amp;, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;)&gt;</td></tr>
<tr class="separator:a64287edfda9bc2abbdafd958b6cfe682 inherit pub_types_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8f2e736a7503314f96d47b099db2b4ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a8f2e736a7503314f96d47b099db2b4ca">LinearEigensystemDavidson</a> (const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;(), const std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt; &amp;logger_=std::make_shared&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt;())</td></tr>
<tr class="separator:a8f2e736a7503314f96d47b099db2b4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a262897f82aa5a3ed099646e05ab73372"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a262897f82aa5a3ed099646e05ab73372">nonlinear</a> () const override</td></tr>
<tr class="memdesc:a262897f82aa5a3ed099646e05ab73372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report whether the class is a non-linear solver.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a262897f82aa5a3ed099646e05ab73372">More...</a><br /></td></tr>
<tr class="separator:a262897f82aa5a3ed099646e05ab73372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22ed76de01c073008465614a389df5c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a22ed76de01c073008465614a389df5c3">end_iteration</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;action) override</td></tr>
<tr class="memdesc:a22ed76de01c073008465614a389df5c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Proposes new parameters for the subspace from the preconditioned residuals.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a22ed76de01c073008465614a389df5c3">More...</a><br /></td></tr>
<tr class="separator:a22ed76de01c073008465614a389df5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f3c0bb3e790c82ffebbfbe62d1d3a9c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a5f3c0bb3e790c82ffebbfbe62d1d3a9c">end_iteration</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;action) override</td></tr>
<tr class="separator:a5f3c0bb3e790c82ffebbfbe62d1d3a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcf854909acb92f11bb2ea33a596c64"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#aebcf854909acb92f11bb2ea33a596c64">end_iteration</a> (R &amp;parameters, R &amp;actions) override</td></tr>
<tr class="separator:aebcf854909acb92f11bb2ea33a596c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a707d2bc8900f8b0478c881ef99cf4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a66a707d2bc8900f8b0478c881ef99cf4">precondition</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;action) const</td></tr>
<tr class="memdesc:a66a707d2bc8900f8b0478c881ef99cf4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies the Davidson preconditioner.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a66a707d2bc8900f8b0478c881ef99cf4">More...</a><br /></td></tr>
<tr class="separator:a66a707d2bc8900f8b0478c881ef99cf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a426a9ce704e73bace85208b85401adf6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a426a9ce704e73bace85208b85401adf6">eigenvalues</a> () const override</td></tr>
<tr class="memdesc:a426a9ce704e73bace85208b85401adf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The calculated eigenvalues of the subspace matrix.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a426a9ce704e73bace85208b85401adf6">More...</a><br /></td></tr>
<tr class="separator:a426a9ce704e73bace85208b85401adf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a2a2e484b7fae18900e2a12b120324a"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a9a2a2e484b7fae18900e2a12b120324a">working_set_eigenvalues</a> () const override</td></tr>
<tr class="separator:a9a2a2e484b7fae18900e2a12b120324a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8358829492685415686f92b83d7962fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a8358829492685415686f92b83d7962fc">set_value_errors</a> () override</td></tr>
<tr class="memdesc:a8358829492685415686f92b83d7962fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation class should overload this to set errors in the current values (e.g. change in eigenvalues)  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a8358829492685415686f92b83d7962fc">More...</a><br /></td></tr>
<tr class="separator:a8358829492685415686f92b83d7962fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac264beb56a500ce1a90edd391ad16b87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ac264beb56a500ce1a90edd391ad16b87">report</a> (std::ostream &amp;cout, bool endl=true) const override</td></tr>
<tr class="memdesc:ac264beb56a500ce1a90edd391ad16b87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a report to cout output stream.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ac264beb56a500ce1a90edd391ad16b87">More...</a><br /></td></tr>
<tr class="separator:ac264beb56a500ce1a90edd391ad16b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4e8f66aaaa54da8eb41e2a5733ece1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ab4e8f66aaaa54da8eb41e2a5733ece1d">set_reset_D</a> (size_t n)</td></tr>
<tr class="memdesc:ab4e8f66aaaa54da8eb41e2a5733ece1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the period in iterations for resetting the D space.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ab4e8f66aaaa54da8eb41e2a5733ece1d">More...</a><br /></td></tr>
<tr class="separator:ab4e8f66aaaa54da8eb41e2a5733ece1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a925f70a6fb1a01ede8dd5a6dc0b7dedb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a925f70a6fb1a01ede8dd5a6dc0b7dedb">get_reset_D</a> () const</td></tr>
<tr class="separator:a925f70a6fb1a01ede8dd5a6dc0b7dedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a241caed8a5b1e346fc978729892f6260"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a241caed8a5b1e346fc978729892f6260">set_reset_D_maxQ_size</a> (size_t n)</td></tr>
<tr class="memdesc:a241caed8a5b1e346fc978729892f6260"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the maximum size of Q space after resetting the D space.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a241caed8a5b1e346fc978729892f6260">More...</a><br /></td></tr>
<tr class="separator:a241caed8a5b1e346fc978729892f6260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dabbe4326a656e6cb8f9a1018ceca3d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a1dabbe4326a656e6cb8f9a1018ceca3d">get_reset_D_maxQ_size</a> () const</td></tr>
<tr class="separator:a1dabbe4326a656e6cb8f9a1018ceca3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053621c2fdae8dcf9c4542ee97888ff7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a053621c2fdae8dcf9c4542ee97888ff7">get_max_size_qspace</a> () const</td></tr>
<tr class="separator:a053621c2fdae8dcf9c4542ee97888ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b363a8031dc1b31e0d70783428a5ab9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a5b363a8031dc1b31e0d70783428a5ab9">set_max_size_qspace</a> (int n)</td></tr>
<tr class="separator:a5b363a8031dc1b31e0d70783428a5ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30cfe987c737da469e7a86a8725586a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a30cfe987c737da469e7a86a8725586a4">set_hermiticity</a> (bool hermitian) override</td></tr>
<tr class="memdesc:a30cfe987c737da469e7a86a8725586a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets hermiticity of kernel.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a30cfe987c737da469e7a86a8725586a4">More...</a><br /></td></tr>
<tr class="separator:a30cfe987c737da469e7a86a8725586a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0109d914fa9d1c4f40fdc54b835efa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a3a0109d914fa9d1c4f40fdc54b835efa">get_hermiticity</a> () const override</td></tr>
<tr class="memdesc:a3a0109d914fa9d1c4f40fdc54b835efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets hermiticity of kernel, if true than it is hermitian, otherwise it is not.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a3a0109d914fa9d1c4f40fdc54b835efa">More...</a><br /></td></tr>
<tr class="separator:a3a0109d914fa9d1c4f40fdc54b835efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa46edad2cecdac0a051062435a7188f1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#aa46edad2cecdac0a051062435a7188f1">set_options</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>) override</td></tr>
<tr class="separator:aa46edad2cecdac0a051062435a7188f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b441426da9570bcc37a7d393be8839c"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a7b441426da9570bcc37a7d393be8839c">get_options</a> () const override</td></tr>
<tr class="separator:a7b441426da9570bcc37a7d393be8839c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a></td></tr>
<tr class="memitem:acd19351fb4f3e8e98507cf0ec6b0032a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#acd19351fb4f3e8e98507cf0ec6b0032a">IterativeSolverTemplate</a> ()=delete</td></tr>
<tr class="separator:acd19351fb4f3e8e98507cf0ec6b0032a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac708b53560e38d7928e84868f6e1091 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aac708b53560e38d7928e84868f6e1091">IterativeSolverTemplate</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;)=delete</td></tr>
<tr class="separator:aac708b53560e38d7928e84868f6e1091 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc08e3ccc737019e8a77796deea4b417 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#afc08e3ccc737019e8a77796deea4b417">IterativeSolverTemplate</a> (<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:afc08e3ccc737019e8a77796deea4b417 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc0d5716fac5bcfd4404859b58925162 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#acc0d5716fac5bcfd4404859b58925162">operator=</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;)=delete</td></tr>
<tr class="separator:acc0d5716fac5bcfd4404859b58925162 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27eb5aadf2d9e18c6c902b602c242f1 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa27eb5aadf2d9e18c6c902b602c242f1">operator=</a> (<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:aa27eb5aadf2d9e18c6c902b602c242f1 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ed89e3da36e7f9e4b065213826e703 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa5ed89e3da36e7f9e4b065213826e703">add_vector</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions) override</td></tr>
<tr class="separator:aa5ed89e3da36e7f9e4b065213826e703 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aaa9e988aa4524bed5a639314b6b2c inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a91aaa9e988aa4524bed5a639314b6b2c">add_vector</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;actions) override</td></tr>
<tr class="separator:a91aaa9e988aa4524bed5a639314b6b2c inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96d822e308648c5e295389bcdd460ea inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac96d822e308648c5e295389bcdd460ea">add_vector</a> (R &amp;parameters, R &amp;actions, <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2cfe4f0a54b136895de82f5a357e4cd4">value</a>=0) override</td></tr>
<tr class="separator:ac96d822e308648c5e295389bcdd460ea inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d1c168044d4511885f06f8aa50f618e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a1d1c168044d4511885f06f8aa50f618e">add_p</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; std::map&lt; size_t, typename R::value_type &gt; &gt; &amp;pparams, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> &gt; &amp;pp_action_matrix, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions, <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a64287edfda9bc2abbdafd958b6cfe682">fapply_on_p_type</a> apply_p) override</td></tr>
<tr class="separator:a1d1c168044d4511885f06f8aa50f618e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa72cab3838296b747e499d86682b3728 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa72cab3838296b747e499d86682b3728">clearP</a> () override</td></tr>
<tr class="separator:aa72cab3838296b747e499d86682b3728 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e0f137f12bf9731d347f9dcc451b0b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af4e0f137f12bf9731d347f9dcc451b0b">solution</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;residual) override</td></tr>
<tr class="separator:af4e0f137f12bf9731d347f9dcc451b0b inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493bdf1e89e15c55b9a82425864ca610 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a493bdf1e89e15c55b9a82425864ca610">solution</a> (const std::vector&lt; int &gt; &amp;roots, std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;residual) override</td></tr>
<tr class="separator:a493bdf1e89e15c55b9a82425864ca610 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c813a5516113c4fdc5dc9abd44fa87 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a97c813a5516113c4fdc5dc9abd44fa87">solution</a> (R &amp;parameters, R &amp;residual) override</td></tr>
<tr class="separator:a97c813a5516113c4fdc5dc9abd44fa87 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238c04489ae2e21f9f188a80aacbae11 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a238c04489ae2e21f9f188a80aacbae11">solution_params</a> (const std::vector&lt; int &gt; &amp;roots, std::vector&lt; R &gt; &amp;parameters) override</td></tr>
<tr class="separator:a238c04489ae2e21f9f188a80aacbae11 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa292796dc4eed09b0131e887f0f5c174 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa292796dc4eed09b0131e887f0f5c174">solution_params</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters) override</td></tr>
<tr class="separator:aa292796dc4eed09b0131e887f0f5c174 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c5d693781ef363399bdc62832135f9 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a92c5d693781ef363399bdc62832135f9">solution_params</a> (R &amp;parameters) override</td></tr>
<tr class="separator:a92c5d693781ef363399bdc62832135f9 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3757611a67f2b2778117f0da79ecb9c2 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3757611a67f2b2778117f0da79ecb9c2">suggest_p</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af4e0f137f12bf9731d347f9dcc451b0b">solution</a>, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;residual, size_t max_number, double threshold) override</td></tr>
<tr class="separator:a3757611a67f2b2778117f0da79ecb9c2 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c2e3ff18eb3f3d87fa76451063f42ea inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2c2e3ff18eb3f3d87fa76451063f42ea">working_set</a> () const override</td></tr>
<tr class="separator:a2c2e3ff18eb3f3d87fa76451063f42ea inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d328cf80c92a542338fcaf30f8e0606 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a6d328cf80c92a542338fcaf30f8e0606">n_roots</a> () const override</td></tr>
<tr class="separator:a6d328cf80c92a542338fcaf30f8e0606 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a326a2d0f672de203c54bbde4b7020368 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a326a2d0f672de203c54bbde4b7020368">set_n_roots</a> (size_t roots) override</td></tr>
<tr class="separator:a326a2d0f672de203c54bbde4b7020368 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3edaefda50129b65bd9b829a3d7d931 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac3edaefda50129b65bd9b829a3d7d931">set_options</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &amp;options) override</td></tr>
<tr class="separator:ac3edaefda50129b65bd9b829a3d7d931 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554d0cbaa18c0c1bd4946b07104c1f9c inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a554d0cbaa18c0c1bd4946b07104c1f9c">get_options</a> () const override</td></tr>
<tr class="separator:a554d0cbaa18c0c1bd4946b07104c1f9c inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8eecdde41014ff248617958739b2378 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad8eecdde41014ff248617958739b2378">errors</a> () const override</td></tr>
<tr class="separator:ad8eecdde41014ff248617958739b2378 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb560bb4c5d91269d5fcc4599e17d82a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#afb560bb4c5d91269d5fcc4599e17d82a">statistics</a> () const override</td></tr>
<tr class="separator:afb560bb4c5d91269d5fcc4599e17d82a inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2586061786c83f40ee932189f6a59353 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2586061786c83f40ee932189f6a59353">report</a> (std::ostream &amp;cout, bool endl=true) const override</td></tr>
<tr class="separator:a2586061786c83f40ee932189f6a59353 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4748964a82d882be6cfebd7c158511e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab4748964a82d882be6cfebd7c158511e">report</a> () const override</td></tr>
<tr class="separator:ab4748964a82d882be6cfebd7c158511e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215df7cdb4fd2d07f3c7f4acb7c58f34 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a215df7cdb4fd2d07f3c7f4acb7c58f34">set_convergence_threshold</a> (double thresh) override</td></tr>
<tr class="separator:a215df7cdb4fd2d07f3c7f4acb7c58f34 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d42e5e1955b041a57e421a4439d53c0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a6d42e5e1955b041a57e421a4439d53c0">convergence_threshold</a> () const override</td></tr>
<tr class="separator:a6d42e5e1955b041a57e421a4439d53c0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa13ca336fed0aea5f331e023f3d626b1 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aa13ca336fed0aea5f331e023f3d626b1">set_convergence_threshold_value</a> (double thresh) override</td></tr>
<tr class="separator:aa13ca336fed0aea5f331e023f3d626b1 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b475dca1b9e715b5aefd549acc48dc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a76b475dca1b9e715b5aefd549acc48dc">convergence_threshold_value</a> () const override</td></tr>
<tr class="separator:a76b475dca1b9e715b5aefd549acc48dc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6ffddd7ef42abcddf96847b6fe3e897 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad6ffddd7ef42abcddf96847b6fe3e897">set_verbosity</a> (<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a> v) override</td></tr>
<tr class="separator:ad6ffddd7ef42abcddf96847b6fe3e897 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1240a8405dbaa9cda64e3d684bce2d5 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af1240a8405dbaa9cda64e3d684bce2d5">set_verbosity</a> (int v) override</td></tr>
<tr class="separator:af1240a8405dbaa9cda64e3d684bce2d5 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af20d7396488162b24ab0565201132fc0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af20d7396488162b24ab0565201132fc0">get_verbosity</a> () const override</td></tr>
<tr class="separator:af20d7396488162b24ab0565201132fc0 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d206ec8158a042fa45b50eb417dd24d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a4d206ec8158a042fa45b50eb417dd24d">set_max_iter</a> (int n) override</td></tr>
<tr class="separator:a4d206ec8158a042fa45b50eb417dd24d inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227f5b950f220fef378ee86ec7b9da92 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a227f5b950f220fef378ee86ec7b9da92">get_max_iter</a> () const override</td></tr>
<tr class="separator:a227f5b950f220fef378ee86ec7b9da92 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1240d8cc340f434400894f5504e913 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a5f1240d8cc340f434400894f5504e913">set_max_p</a> (int n) override</td></tr>
<tr class="separator:a5f1240d8cc340f434400894f5504e913 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f2b7857436d5df6cb76a1fa51f4135 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a64f2b7857436d5df6cb76a1fa51f4135">get_max_p</a> () const override</td></tr>
<tr class="separator:a64f2b7857436d5df6cb76a1fa51f4135 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f49c4695490cbd7107eddda0a5bc7b3 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a8f49c4695490cbd7107eddda0a5bc7b3">set_p_threshold</a> (double threshold) override</td></tr>
<tr class="separator:a8f49c4695490cbd7107eddda0a5bc7b3 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a261ed5e2536b16ce500022eac143b541 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a261ed5e2536b16ce500022eac143b541">get_p_threshold</a> () const override</td></tr>
<tr class="separator:a261ed5e2536b16ce500022eac143b541 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77261809d0ff2ecb69a4b910e3523d4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1Dimensions.html">subspace::Dimensions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae77261809d0ff2ecb69a4b910e3523d4">dimensions</a> () const override</td></tr>
<tr class="memdesc:ae77261809d0ff2ecb69a4b910e3523d4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access dimensions of the subspace.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae77261809d0ff2ecb69a4b910e3523d4">More...</a><br /></td></tr>
<tr class="separator:ae77261809d0ff2ecb69a4b910e3523d4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfe4f0a54b136895de82f5a357e4cd4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2cfe4f0a54b136895de82f5a357e4cd4">value</a> () const override</td></tr>
<tr class="separator:a2cfe4f0a54b136895de82f5a357e4cd4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17509a0c4ccbd30a313f3e606dc54696 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a17509a0c4ccbd30a313f3e606dc54696">set_profiler</a> (molpro::profiler::Profiler &amp;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2d3b7ce6cbe13ca8742deae8f62aad29">profiler</a>) override</td></tr>
<tr class="separator:a17509a0c4ccbd30a313f3e606dc54696 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d3b7ce6cbe13ca8742deae8f62aad29 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; molpro::profiler::Profiler &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2d3b7ce6cbe13ca8742deae8f62aad29">profiler</a> () const override</td></tr>
<tr class="separator:a2d3b7ce6cbe13ca8742deae8f62aad29 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad86a191289fae16f2d6df34f3b3ddad4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad86a191289fae16f2d6df34f3b3ddad4">solve</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false) override</td></tr>
<tr class="separator:ad86a191289fae16f2d6df34f3b3ddad4 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa15c94f22aef32292f8c81bc4d5b4dc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#aaa15c94f22aef32292f8c81bc4d5b4dc">solve</a> (R &amp;parameters, R &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false) override</td></tr>
<tr class="separator:aaa15c94f22aef32292f8c81bc4d5b4dc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0f9db2eec5cb8d9153fe5ab23db017f inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac0f9db2eec5cb8d9153fe5ab23db017f">solve</a> (std::vector&lt; R &gt; &amp;parameters, std::vector&lt; R &gt; &amp;actions, const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a>&lt; R &gt; &amp;problem, bool generate_initial_guess=false) override</td></tr>
<tr class="separator:ac0f9db2eec5cb8d9153fe5ab23db017f inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a></td></tr>
<tr class="memitem:abc808a3db4d9f21e50b071fee35cb083 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#abc808a3db4d9f21e50b071fee35cb083">~IterativeSolver</a> ()=default</td></tr>
<tr class="separator:abc808a3db4d9f21e50b071fee35cb083 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e49705c8f5b805ff69f535ffcba5efc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a7e49705c8f5b805ff69f535ffcba5efc">IterativeSolver</a> ()=default</td></tr>
<tr class="separator:a7e49705c8f5b805ff69f535ffcba5efc inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dab6f5601a84fa64d00e8e5628a3a1e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a0dab6f5601a84fa64d00e8e5628a3a1e">IterativeSolver</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, Q, P &gt; &amp;)=delete</td></tr>
<tr class="separator:a0dab6f5601a84fa64d00e8e5628a3a1e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f0ad1395b29b996dbcd447fa1fd9be1 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, Q, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a6f0ad1395b29b996dbcd447fa1fd9be1">operator=</a> (const <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, Q, P &gt; &amp;)=delete</td></tr>
<tr class="separator:a6f0ad1395b29b996dbcd447fa1fd9be1 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3becd034ba0358533dda8362a1283a01 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a3becd034ba0358533dda8362a1283a01">IterativeSolver</a> (<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, Q, P &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a3becd034ba0358533dda8362a1283a01 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d47710ca4c0a27a03f5083e7f08be0e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, Q, P &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a5d47710ca4c0a27a03f5083e7f08be0e">operator=</a> (<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a>&lt; R, Q, P &gt; &amp;&amp;) noexcept=default</td></tr>
<tr class="separator:a5d47710ca4c0a27a03f5083e7f08be0e inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2cb71b3bc51e8163c0658113fb2929 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9f2cb71b3bc51e8163c0658113fb2929">add_p</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; P &gt; &amp;pparams, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a027b41582a1fff9ebb679e6ae6e2fe5f">value_type</a> &gt; &amp;pp_action_matrix, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;action, <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a64287edfda9bc2abbdafd958b6cfe682">fapply_on_p_type</a> apply_p)=0</td></tr>
<tr class="memdesc:a9f2cb71b3bc51e8163c0658113fb2929 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add P-space vectors to the expansion set for linear methods.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9f2cb71b3bc51e8163c0658113fb2929">More...</a><br /></td></tr>
<tr class="separator:a9f2cb71b3bc51e8163c0658113fb2929 inherit pub_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a3928db7987c24bda78d24e2f18e6c1d5"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a3928db7987c24bda78d24e2f18e6c1d5">logger</a></td></tr>
<tr class="separator:a3928db7987c24bda78d24e2f18e6c1d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc0bdc92047dafddad208549048eef54"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#abc0bdc92047dafddad208549048eef54">propose_rspace_norm_thresh</a> = 1e-10</td></tr>
<tr class="memdesc:abc0bdc92047dafddad208549048eef54"><td class="mdescLeft">&#160;</td><td class="mdescRight">vectors with norm less than threshold can be considered null.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#abc0bdc92047dafddad208549048eef54">More...</a><br /></td></tr>
<tr class="separator:abc0bdc92047dafddad208549048eef54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b96209972872ffece08f78a2c747c5a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a3b96209972872ffece08f78a2c747c5a">propose_rspace_svd_thresh</a> = 1e-12</td></tr>
<tr class="separator:a3b96209972872ffece08f78a2c747c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:accbb21b9dc3c611e7bddd25d0750f972"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#accbb21b9dc3c611e7bddd25d0750f972">construct_residual</a> (const std::vector&lt; int &gt; &amp;roots, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;params, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;actions) override</td></tr>
<tr class="memdesc:accbb21b9dc3c611e7bddd25d0750f972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs residual for given roots provided their parameters and actions.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#accbb21b9dc3c611e7bddd25d0750f972">More...</a><br /></td></tr>
<tr class="separator:accbb21b9dc3c611e7bddd25d0750f972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a></td></tr>
<tr class="memitem:a923e1c476bdebbe62b6926823b6e88bb inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a923e1c476bdebbe62b6926823b6e88bb">IterativeSolverTemplate</a> (std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1IXSpace.html">subspace::IXSpace</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;&gt; xspace, std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1ISubspaceSolver.html">subspace::ISubspaceSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;&gt; solver, std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;&gt; handlers, std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &gt; stats, std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt; logger)</td></tr>
<tr class="separator:a923e1c476bdebbe62b6926823b6e88bb inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da70aeae03caac6b144251c0d402d4c inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a8da70aeae03caac6b144251c0d402d4c">~IterativeSolverTemplate</a> ()</td></tr>
<tr class="separator:a8da70aeae03caac6b144251c0d402d4c inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e68e1074cbc61076df22c6dc8d787a inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a92e68e1074cbc61076df22c6dc8d787a">linearEigensystem</a> () const</td></tr>
<tr class="separator:a92e68e1074cbc61076df22c6dc8d787a inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b1a5bfc4fb3d6876ab8535be73e69ce inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a7b1a5bfc4fb3d6876ab8535be73e69ce">solve_and_generate_working_set</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;parameters, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;action)</td></tr>
<tr class="memdesc:a7b1a5bfc4fb3d6876ab8535be73e69ce inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the subspace problems and selects the working set of roots, returning their parameters and residual in parameters and action.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a7b1a5bfc4fb3d6876ab8535be73e69ce">More...</a><br /></td></tr>
<tr class="separator:a7b1a5bfc4fb3d6876ab8535be73e69ce inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c5badcc785eede77893bfe2c8c8cb9 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a54c5badcc785eede77893bfe2c8c8cb9">check_consistent_number_of_roots_and_solutions</a> (const std::vector&lt; TTT &gt; &amp;roots, const size_t nparams)</td></tr>
<tr class="separator:a54c5badcc785eede77893bfe2c8c8cb9 inherit pro_methods_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a482db55c4914b82cedcbbb3190c519f8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a482db55c4914b82cedcbbb3190c519f8">m_max_size_qspace</a> = std::numeric_limits&lt;int&gt;::max()</td></tr>
<tr class="memdesc:a482db55c4914b82cedcbbb3190c519f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum size of Q space  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a482db55c4914b82cedcbbb3190c519f8">More...</a><br /></td></tr>
<tr class="separator:a482db55c4914b82cedcbbb3190c519f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f58e57011e81a3649959d5bf900b59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1detail_1_1DSpaceResetter.html">detail::DSpaceResetter</a>&lt; Q &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a54f58e57011e81a3649959d5bf900b59">m_dspace_resetter</a></td></tr>
<tr class="memdesc:a54f58e57011e81a3649959d5bf900b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">resets D space  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a54f58e57011e81a3649959d5bf900b59">More...</a><br /></td></tr>
<tr class="separator:a54f58e57011e81a3649959d5bf900b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf051b5bc298da49a9046af0feb0104"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a9bf051b5bc298da49a9046af0feb0104">m_hermiticity</a> = false</td></tr>
<tr class="memdesc:a9bf051b5bc298da49a9046af0feb0104"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether the problem is hermitian or not  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a9bf051b5bc298da49a9046af0feb0104">More...</a><br /></td></tr>
<tr class="separator:a9bf051b5bc298da49a9046af0feb0104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f7dd1a80e4fdda081a2353d3cabb9e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a26f7dd1a80e4fdda081a2353d3cabb9e">m_last_values</a></td></tr>
<tr class="memdesc:a26f7dd1a80e4fdda081a2353d3cabb9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">The values from the previous iteration.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a26f7dd1a80e4fdda081a2353d3cabb9e">More...</a><br /></td></tr>
<tr class="separator:a26f7dd1a80e4fdda081a2353d3cabb9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8b13cbdbd2dc723312d0d640c31917"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a4f8b13cbdbd2dc723312d0d640c31917">m_resetting_in_progress</a> = false</td></tr>
<tr class="memdesc:a4f8b13cbdbd2dc723312d0d640c31917"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether D space resetting is in progress  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#a4f8b13cbdbd2dc723312d0d640c31917">More...</a><br /></td></tr>
<tr class="separator:a4f8b13cbdbd2dc723312d0d640c31917"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a></td></tr>
<tr class="memitem:a3a9fde47c295d0370ba3d65b91bc9b95 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3a9fde47c295d0370ba3d65b91bc9b95">m_handlers</a></td></tr>
<tr class="memdesc:a3a9fde47c295d0370ba3d65b91bc9b95 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array handlers.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3a9fde47c295d0370ba3d65b91bc9b95">More...</a><br /></td></tr>
<tr class="separator:a3a9fde47c295d0370ba3d65b91bc9b95 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc73bdfa7e204116edab2d44b69e7cd inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1IXSpace.html">subspace::IXSpace</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2dc73bdfa7e204116edab2d44b69e7cd">m_xspace</a></td></tr>
<tr class="memdesc:a2dc73bdfa7e204116edab2d44b69e7cd inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">manages the subspace and associated data  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a2dc73bdfa7e204116edab2d44b69e7cd">More...</a><br /></td></tr>
<tr class="separator:a2dc73bdfa7e204116edab2d44b69e7cd inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e18e30ed35370994bb53003a5d4642 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1subspace_1_1ISubspaceSolver.html">subspace::ISubspaceSolver</a>&lt; R, R, std::map&lt; size_t, typename R::value_type &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a61e18e30ed35370994bb53003a5d4642">m_subspace_solver</a></td></tr>
<tr class="memdesc:a61e18e30ed35370994bb53003a5d4642 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">solves the subspace problem  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a61e18e30ed35370994bb53003a5d4642">More...</a><br /></td></tr>
<tr class="separator:a61e18e30ed35370994bb53003a5d4642 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac50fb7b6de5f3cfa26e703337060a0da inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac50fb7b6de5f3cfa26e703337060a0da">m_errors</a></td></tr>
<tr class="memdesc:ac50fb7b6de5f3cfa26e703337060a0da inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">errors from the most recent solution  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac50fb7b6de5f3cfa26e703337060a0da">More...</a><br /></td></tr>
<tr class="separator:ac50fb7b6de5f3cfa26e703337060a0da inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75da06fcb4b67cbed43a74142eebb56 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af75da06fcb4b67cbed43a74142eebb56">m_value_errors</a></td></tr>
<tr class="memdesc:af75da06fcb4b67cbed43a74142eebb56 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">value errors from the most recent solution  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#af75da06fcb4b67cbed43a74142eebb56">More...</a><br /></td></tr>
<tr class="separator:af75da06fcb4b67cbed43a74142eebb56 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a289ff256b61bc1746f7dd0fddd0b8166 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a289ff256b61bc1746f7dd0fddd0b8166">m_working_set</a></td></tr>
<tr class="memdesc:a289ff256b61bc1746f7dd0fddd0b8166 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">indices of roots in the working set  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a289ff256b61bc1746f7dd0fddd0b8166">More...</a><br /></td></tr>
<tr class="separator:a289ff256b61bc1746f7dd0fddd0b8166 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b5c7aee955bf41e7ad1d7a1889ce6e0 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a9b5c7aee955bf41e7ad1d7a1889ce6e0">m_nroots</a></td></tr>
<tr class="memdesc:a9b5c7aee955bf41e7ad1d7a1889ce6e0 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of roots the solver is searching for  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a9b5c7aee955bf41e7ad1d7a1889ce6e0">More...</a><br /></td></tr>
<tr class="separator:a9b5c7aee955bf41e7ad1d7a1889ce6e0 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab88aa2f7710140556b2e670a54730784 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab88aa2f7710140556b2e670a54730784">m_convergence_threshold</a></td></tr>
<tr class="memdesc:ab88aa2f7710140556b2e670a54730784 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">residual norms less than this mark a converged solution  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab88aa2f7710140556b2e670a54730784">More...</a><br /></td></tr>
<tr class="separator:ab88aa2f7710140556b2e670a54730784 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae91c0ec6524d77c5a789f61995a01c43 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae91c0ec6524d77c5a789f61995a01c43">m_convergence_threshold_value</a></td></tr>
<tr class="memdesc:ae91c0ec6524d77c5a789f61995a01c43 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">value changes less than this mark a converged solution  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae91c0ec6524d77c5a789f61995a01c43">More...</a><br /></td></tr>
<tr class="separator:ae91c0ec6524d77c5a789f61995a01c43 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24be2854a659d0b3c5a3fe8db922e5e inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae24be2854a659d0b3c5a3fe8db922e5e">m_stats</a></td></tr>
<tr class="memdesc:ae24be2854a659d0b3c5a3fe8db922e5e inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">accumulates statistics of operations performed by the solver  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae24be2854a659d0b3c5a3fe8db922e5e">More...</a><br /></td></tr>
<tr class="separator:ae24be2854a659d0b3c5a3fe8db922e5e inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee358ce5516717e73670d75f2eebc45 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abee358ce5516717e73670d75f2eebc45">m_logger</a></td></tr>
<tr class="memdesc:abee358ce5516717e73670d75f2eebc45 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">logger  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abee358ce5516717e73670d75f2eebc45">More...</a><br /></td></tr>
<tr class="separator:abee358ce5516717e73670d75f2eebc45 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53e871487e088b6502f51f6ec2ccab3 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab53e871487e088b6502f51f6ec2ccab3">m_normalise_solution</a></td></tr>
<tr class="memdesc:ab53e871487e088b6502f51f6ec2ccab3 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to normalise the solutions  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ab53e871487e088b6502f51f6ec2ccab3">More...</a><br /></td></tr>
<tr class="separator:ab53e871487e088b6502f51f6ec2ccab3 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd09e6fa94c79029c5b876ea509edb9 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a64287edfda9bc2abbdafd958b6cfe682">fapply_on_p_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3dd09e6fa94c79029c5b876ea509edb9">m_apply_p</a></td></tr>
<tr class="memdesc:a3dd09e6fa94c79029c5b876ea509edb9 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">function that evaluates effect of action on the P space projection  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a3dd09e6fa94c79029c5b876ea509edb9">More...</a><br /></td></tr>
<tr class="separator:a3dd09e6fa94c79029c5b876ea509edb9 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e460814c7e8040c9a6fed3de9e3026 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac3e460814c7e8040c9a6fed3de9e3026">m_verbosity</a></td></tr>
<tr class="memdesc:ac3e460814c7e8040c9a6fed3de9e3026 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">how much output to print in <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad86a191289fae16f2d6df34f3b3ddad4" title="Simplified one-call solver.">solve()</a>  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac3e460814c7e8040c9a6fed3de9e3026">More...</a><br /></td></tr>
<tr class="separator:ac3e460814c7e8040c9a6fed3de9e3026 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0d0a39af9d4914c52f317d51f6fd084 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae0d0a39af9d4914c52f317d51f6fd084">m_max_iter</a></td></tr>
<tr class="memdesc:ae0d0a39af9d4914c52f317d51f6fd084 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum number of iterations in <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ad86a191289fae16f2d6df34f3b3ddad4" title="Simplified one-call solver.">solve()</a>  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ae0d0a39af9d4914c52f317d51f6fd084">More...</a><br /></td></tr>
<tr class="separator:ae0d0a39af9d4914c52f317d51f6fd084 inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b4f79b443412af94b4e9dbd19254bb inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a75b4f79b443412af94b4e9dbd19254bb">m_max_p</a></td></tr>
<tr class="memdesc:a75b4f79b443412af94b4e9dbd19254bb inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">maximum size of P space  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a75b4f79b443412af94b4e9dbd19254bb">More...</a><br /></td></tr>
<tr class="separator:a75b4f79b443412af94b4e9dbd19254bb inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cd1557340c1bdd64cf98ffdd3e6287a inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a9cd1557340c1bdd64cf98ffdd3e6287a">m_p_threshold</a></td></tr>
<tr class="memdesc:a9cd1557340c1bdd64cf98ffdd3e6287a inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="mdescLeft">&#160;</td><td class="mdescRight">threshold for selecting P space  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#a9cd1557340c1bdd64cf98ffdd3e6287a">More...</a><br /></td></tr>
<tr class="separator:a9cd1557340c1bdd64cf98ffdd3e6287a inherit pro_attribs_classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae0ec3d737bc94543b35dc4d0e3558470"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0ec3d737bc94543b35dc4d0e3558470">&#9670;&nbsp;</a></span>SolverTemplate</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#ae0ec3d737bc94543b35dc4d0e3558470">SolverTemplate</a> =  <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a>&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>, R, Q, P&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a8f2e736a7503314f96d47b099db2b4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f2e736a7503314f96d47b099db2b4ca">&#9670;&nbsp;</a></span>LinearEigensystemDavidson()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">LinearEigensystemDavidson</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>logger_</em> = <code>std::make_shared&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="accbb21b9dc3c611e7bddd25d0750f972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accbb21b9dc3c611e7bddd25d0750f972">&#9670;&nbsp;</a></span>construct_residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::construct_residual </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>roots</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>actions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs residual for given roots provided their parameters and actions. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#ac38e5b3cb441edb495c6084a72dbdac0">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a426a9ce704e73bace85208b85401adf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a426a9ce704e73bace85208b85401adf6">&#9670;&nbsp;</a></span>eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a>&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::eigenvalues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The calculated eigenvalues of the subspace matrix. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#ad4de46c943ba6b56a9c3c054952332a0">molpro::linalg::itsolv::LinearEigensystem&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="a22ed76de01c073008465614a389df5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22ed76de01c073008465614a389df5c3">&#9670;&nbsp;</a></span>end_iteration() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::end_iteration </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Proposes new parameters for the subspace from the preconditioned residuals. </p>
<p>After add_vector solves the subspace problem it returns the new solution and residual. The residual should be preconditioned, i.e. using Davidson method, to accelerate convergence. The updated residual is used in this function to propose new Q space parameters orthonormal to the old space. They are returned in parameters so that corresponding actions can be calculated and used in add_vector in the next iteration.</p>
<p>Every n_reset_D iterations the D space has to be reset. If working set does not cover all solutions than resetting is done over multiple iterations. During this time, there are no deletions from the Q space. This is done by temporarily increasing maximum allowed size of Q space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>output new parameters for the subspace. </td></tr>
    <tr><td class="paramname">residual</td><td>preconditioned residuals. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of significant parameters to calculate the action for </dd></dl>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#acfce319e750a3e3a925c489b91dbf7e2">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="aebcf854909acb92f11bb2ea33a596c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcf854909acb92f11bb2ea33a596c64">&#9670;&nbsp;</a></span>end_iteration() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::end_iteration </td>
          <td>(</td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">R &amp;&#160;</td>
          <td class="paramname"><em>actions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a1e6b71a13a52437b18b22ace59fcc489">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="a5f3c0bb3e790c82ffebbfbe62d1d3a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f3c0bb3e790c82ffebbfbe62d1d3a9c">&#9670;&nbsp;</a></span>end_iteration() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::end_iteration </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#af866452579638ebfa72eb5aa4e79cb97">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="a3a0109d914fa9d1c4f40fdc54b835efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0109d914fa9d1c4f40fdc54b835efa">&#9670;&nbsp;</a></span>get_hermiticity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_hermiticity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets hermiticity of kernel, if true than it is hermitian, otherwise it is not. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a1280ef097d90b4b1f1ed608db76f1071">molpro::linalg::itsolv::LinearEigensystem&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="a053621c2fdae8dcf9c4542ee97888ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053621c2fdae8dcf9c4542ee97888ff7">&#9670;&nbsp;</a></span>get_max_size_qspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_max_size_qspace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b441426da9570bcc37a7d393be8839c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b441426da9570bcc37a7d393be8839c">&#9670;&nbsp;</a></span>get_options()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a>&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_options </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return all options. This is no different than using getters, but can be used with forward declaration. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#adc1b240bebd35761b7a6a17ce594182d">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="a925f70a6fb1a01ede8dd5a6dc0b7dedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a925f70a6fb1a01ede8dd5a6dc0b7dedb">&#9670;&nbsp;</a></span>get_reset_D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_reset_D </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dabbe4326a656e6cb8f9a1018ceca3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dabbe4326a656e6cb8f9a1018ceca3d">&#9670;&nbsp;</a></span>get_reset_D_maxQ_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::get_reset_D_maxQ_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a262897f82aa5a3ed099646e05ab73372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a262897f82aa5a3ed099646e05ab73372">&#9670;&nbsp;</a></span>nonlinear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::nonlinear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Report whether the class is a non-linear solver. </p>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a66ac1625fde41f28ade6cc29f81da931">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="a66a707d2bc8900f8b0478c881ef99cf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a707d2bc8900f8b0478c881ef99cf4">&#9670;&nbsp;</a></span>precondition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::precondition </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Applies the Davidson preconditioner. </p>

</div>
</div>
<a id="ac264beb56a500ce1a90edd391ad16b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac264beb56a500ce1a90edd391ad16b87">&#9670;&nbsp;</a></span>report()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::report </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>cout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>endl</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Writes a report to cout output stream. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a328990c674d38121f8ebbd5b51a26af0">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="a30cfe987c737da469e7a86a8725586a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30cfe987c737da469e7a86a8725586a4">&#9670;&nbsp;</a></span>set_hermiticity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_hermiticity </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets hermiticity of kernel. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#a66e43e2aa5f24212eb3562324554ce4f">molpro::linalg::itsolv::LinearEigensystem&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="a5b363a8031dc1b31e0d70783428a5ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b363a8031dc1b31e0d70783428a5ab9">&#9670;&nbsp;</a></span>set_max_size_qspace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_max_size_qspace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa46edad2cecdac0a051062435a7188f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa46edad2cecdac0a051062435a7188f1">&#9670;&nbsp;</a></span>set_options()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_options </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set all spcecified options. This is no different than using setters, but can be used with forward declaration. </p>

<p>Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a7e4e385f3faccb93d44a0e1b070bfa74">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<a id="ab4e8f66aaaa54da8eb41e2a5733ece1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4e8f66aaaa54da8eb41e2a5733ece1d">&#9670;&nbsp;</a></span>set_reset_D()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_reset_D </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the period in iterations for resetting the D space. </p>

</div>
</div>
<a id="a241caed8a5b1e346fc978729892f6260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a241caed8a5b1e346fc978729892f6260">&#9670;&nbsp;</a></span>set_reset_D_maxQ_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_reset_D_maxQ_size </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the maximum size of Q space after resetting the D space. </p>

</div>
</div>
<a id="a8358829492685415686f92b83d7962fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8358829492685415686f92b83d7962fc">&#9670;&nbsp;</a></span>set_value_errors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::set_value_errors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implementation class should overload this to set errors in the current values (e.g. change in eigenvalues) </p>

<p>Reimplemented from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#abf9774c4ebf5d2ac8f670236d417ceb6">molpro::linalg::itsolv::IterativeSolverTemplate&lt; LinearEigensystem, R, R, std::map&lt; size_t, typename R::value_type &gt; &gt;</a>.</p>

</div>
</div>
<a id="a9a2a2e484b7fae18900e2a12b120324a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a2a2e484b7fae18900e2a12b120324a">&#9670;&nbsp;</a></span>working_set_eigenvalues()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a4ce4d7778dab44edee1bea7075d7f227">scalar_type</a>&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::working_set_eigenvalues </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The calculated eigenvalues for roots in the working set (eigenvalue problems) or zero (otherwise) </p>

<p>Reimplemented from <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a9a4225adadce2e8fa278f691aaf6c6c9">molpro::linalg::itsolv::IterativeSolver&lt; R, Q, P &gt;</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3928db7987c24bda78d24e2f18e6c1d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3928db7987c24bda78d24e2f18e6c1d5">&#9670;&nbsp;</a></span>logger</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a>&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::logger</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54f58e57011e81a3649959d5bf900b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54f58e57011e81a3649959d5bf900b59">&#9670;&nbsp;</a></span>m_dspace_resetter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1detail_1_1DSpaceResetter.html">detail::DSpaceResetter</a>&lt;Q&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_dspace_resetter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>resets D space </p>

</div>
</div>
<a id="a9bf051b5bc298da49a9046af0feb0104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf051b5bc298da49a9046af0feb0104">&#9670;&nbsp;</a></span>m_hermiticity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_hermiticity = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether the problem is hermitian or not </p>

</div>
</div>
<a id="a26f7dd1a80e4fdda081a2353d3cabb9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f7dd1a80e4fdda081a2353d3cabb9e">&#9670;&nbsp;</a></span>m_last_values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_last_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The values from the previous iteration. </p>

</div>
</div>
<a id="a482db55c4914b82cedcbbb3190c519f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482db55c4914b82cedcbbb3190c519f8">&#9670;&nbsp;</a></span>m_max_size_qspace</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_max_size_qspace = std::numeric_limits&lt;int&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>maximum size of Q space </p>

</div>
</div>
<a id="a4f8b13cbdbd2dc723312d0d640c31917"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8b13cbdbd2dc723312d0d640c31917">&#9670;&nbsp;</a></span>m_resetting_in_progress</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::m_resetting_in_progress = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether D space resetting is in progress </p>

</div>
</div>
<a id="abc0bdc92047dafddad208549048eef54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc0bdc92047dafddad208549048eef54">&#9670;&nbsp;</a></span>propose_rspace_norm_thresh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::propose_rspace_norm_thresh = 1e-10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>vectors with norm less than threshold can be considered null. </p>

</div>
</div>
<a id="a3b96209972872ffece08f78a2c747c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b96209972872ffece08f78a2c747c5a">&#9670;&nbsp;</a></span>propose_rspace_svd_thresh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">molpro::linalg::itsolv::LinearEigensystemDavidson</a>&lt; R, Q, P &gt;::propose_rspace_svd_thresh = 1e-12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>the smallest singular value in the subspace that can be allowed when constructing the working set. Smaller singular values will lead to deletion of parameters from the Q space </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemolpro.html">molpro</a></li><li class="navelem"><a class="el" href="namespacemolpro_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html">itsolv</a></li><li class="navelem"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">LinearEigensystemDavidson</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
