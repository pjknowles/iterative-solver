<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>iterative-solver: molpro::linalg::itsolv Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">iterative-solver
   &#160;<span id="projectnumber">.</span>
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespacemolpro_1_1linalg_1_1itsolv.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">molpro::linalg::itsolv Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>4-parameter interpolation of a 1-dimensional function given two points for which function values and first derivatives are known.  
<a href="namespacemolpro_1_1linalg_1_1itsolv.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacemolpro_1_1linalg_1_1itsolv_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemolpro_1_1linalg_1_1itsolv_1_1subspace"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv_1_1subspace.html">subspace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacemolpro_1_1linalg_1_1itsolv_1_1util"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv_1_1util.html">util</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1is__complex.html">is_complex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1is__complex_3_01std_1_1complex_3_01T_01_4_01_4.html">is_complex&lt; std::complex&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a singular value and corresponding left and right singular vectors.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class, containing a collection of array handlers used in <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> Provides a <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers_1_1Builder.html">Builder</a> sub-class, containing member functions to accumulate user-defined handlers, as well as determine and instantiate default handlers, based on container (template parameter) types.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information about performance of <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> instance.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1has__iterator.html">has_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html">Problem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class defining the problem-specific interface for the simplified solver interface to <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a>.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1Problem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html">IterativeSolver</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class defining the interface common to all iterative solvers.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface for a specific iterative solver, it can add special member functions or variables.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEquations.html">LinearEquations</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Optimize.html">Optimize</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimises to a stationary point using methods such as L-BFGS.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1Optimize.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquations.html">NonLinearEquations</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves non-linear system of equations using methods such as DIIS.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquations.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html">IterativeSolverTemplate</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> interface that is common to all solvers.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolverTemplate.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html">LinearEigensystemDavidson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One specific implementation of <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title="Interface for a specific iterative solver, it can add special member functions or variables.">LinearEigensystem</a> using Davidson's algorithm with modifications to manage near linear dependencies, and consequent numerical noise, in candidate expansion vectors.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html">Options</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access point for different options in iterative solvers.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemOptions.html">LinearEigensystemOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEquationsOptions.html">LinearEquationsOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquationsOptions.html">NonLinearEquationsOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeOptions.html">OptimizeOptions</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEquationsDavidson.html">LinearEquationsDavidson</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equation, A x = b.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEquationsDavidson.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemRSPT.html">LinearEigensystemRSPT</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One specific implementation of <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html" title="Interface for a specific iterative solver, it can add special member functions or variables.">LinearEigensystem</a> using Davidson's algorithm with modifications to manage near linear dependencies, and consequent numerical noise, in candidate expansion vectors.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemRSPT.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1OptimizeBFGS.html">OptimizeBFGS</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that optimises a function using a Quasi-Newton or other method.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1OptimizeBFGS.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1OptimizeSD.html">OptimizeSD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class that optimises a function using a simple steepest-descent method.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1OptimizeSD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html">Logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A dummy structured logger.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1Logger.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1decay.html">decay</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decays CV and reference qualifiers same as std::decay, but also decays std::reference_wrapper to its underlying type.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1decay.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1decay_3_01std_1_1reference__wrapper_3_01T_01_4_01_4.html">decay&lt; std::reference_wrapper&lt; T &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidsonOptions.html">LinearEigensystemDavidsonOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting and getting of options for <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidson.html" title="One specific implementation of LinearEigensystem using Davidson&#39;s algorithm with modifications to man...">LinearEigensystemDavidson</a> instance via <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> base class.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemDavidsonOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1CastOptions.html">CastOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Safely down-cast <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html" title="Access point for different options in iterative solvers.">Options</a> to one of the implementations.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1CastOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemRSPTOptions.html">LinearEigensystemRSPTOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting and getting of options for <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemRSPT.html" title="One specific implementation of LinearEigensystem using Davidson&#39;s algorithm with modifications to man...">LinearEigensystemRSPT</a> instance via <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> base class.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemRSPTOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEquationsDavidsonOptions.html">LinearEquationsDavidsonOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting and getting of options for <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEquationsDavidson.html" title="Solves a system of linear equation, A x = b.">LinearEquationsDavidson</a> instance via <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> base class.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEquationsDavidsonOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1SolverFactory.html">SolverFactory</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Factory for creating instances of specific solver implementations from the corresponding <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Options.html" title="Access point for different options in iterative solvers.">Options</a> object.  <a href="classmolpro_1_1linalg_1_1itsolv_1_1SolverFactory.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeBFGSOptions.html">OptimizeBFGSOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting and getting of options for <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1OptimizeBFGS.html" title="A class that optimises a function using a Quasi-Newton or other method.">OptimizeBFGS</a> instance via <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> base class.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeBFGSOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeSDOptions.html">OptimizeSDOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting and getting of options for <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1OptimizeBFGS.html" title="A class that optimises a function using a Quasi-Newton or other method.">OptimizeBFGS</a> instance via <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> base class.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeSDOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquationsDIISOptions.html">NonLinearEquationsDIISOptions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allows setting and getting of options for NonLinearEquationsDIIS instance via <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html" title="Base class defining the interface common to all iterative solvers.">IterativeSolver</a> base class.  <a href="structmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquationsDIISOptions.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Interpolate.html">Interpolate</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab44c7c7dfce88d39d260d1f5c7b70fab"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:ab44c7c7dfce88d39d260d1f5c7b70fab"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a> = std::vector&lt; std::reference_wrapper&lt; A &gt; &gt;</td></tr>
<tr class="separator:ab44c7c7dfce88d39d260d1f5c7b70fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd1821a97ea122d56be347e38e90a89"><td class="memTemplParams" colspan="2">template&lt;class A &gt; </td></tr>
<tr class="memitem:aafd1821a97ea122d56be347e38e90a89"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a> = std::vector&lt; std::reference_wrapper&lt; const A &gt; &gt;</td></tr>
<tr class="separator:aafd1821a97ea122d56be347e38e90a89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2541a0dfd2575a25a8d4976899b63e1d"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a2541a0dfd2575a25a8d4976899b63e1d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a> = typename <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1decay.html">decay</a>&lt; T &gt;::type</td></tr>
<tr class="separator:a2541a0dfd2575a25a8d4976899b63e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784351a2599ca33773a9809818edb5a1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a784351a2599ca33773a9809818edb5a1">options_map</a> = std::map&lt; std::string, std::string &gt;</td></tr>
<tr class="separator:a784351a2599ca33773a9809818edb5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ac8246e59286ac3630c4c80231d6ed172"><td class="memItemLeft" align="right" valign="top">enum class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">Verbosity</a> { <br />
&#160;&#160;<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172a6adf97f83acf6453d4a6a4b1070f3754">None</a> = 0
, <br />
&#160;&#160;<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172a290612199861c31d1036b185b4e69b75">Summary</a> = 1
, <br />
&#160;&#160;<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172a86c1e32c05338b57578313d8a6fa892d">Iteration</a> = 2
, <br />
&#160;&#160;<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172a4042fcadbe61a3300451157e2c9fe651">Detailed</a> = 3
<br />
 }</td></tr>
<tr class="memdesc:ac8246e59286ac3630c4c80231d6ed172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies how much detail <code>IterativeSolver::solve</code> should write to output.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">More...</a><br /></td></tr>
<tr class="separator:ac8246e59286ac3630c4c80231d6ed172"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac08926114067c3eafad9a758df73dabc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac08926114067c3eafad9a758df73dabc">eigensolver_lapacke_dsyev</a> (const std::vector&lt; double &gt; &amp;matrix, std::vector&lt; double &gt; &amp;eigenvectors, std::vector&lt; double &gt; &amp;eigenvalues, const size_t dimension)</td></tr>
<tr class="separator:ac08926114067c3eafad9a758df73dabc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bdd3fd38d1ba9aa765db3684fb866ff"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a3bdd3fd38d1ba9aa765db3684fb866ff">eigensolver_lapacke_dsyev</a> (size_t dimension, std::vector&lt; double &gt; &amp;matrix)</td></tr>
<tr class="separator:a3bdd3fd38d1ba9aa765db3684fb866ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a516f42ae956054880e6649b626657478"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a516f42ae956054880e6649b626657478">eigensolver_lapacke_dsyev</a> (size_t dimension, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">molpro::linalg::array::span::Span</a>&lt; double &gt; &amp;matrix)</td></tr>
<tr class="separator:a516f42ae956054880e6649b626657478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f4b69d5700c5c0199c7424183b6641f"><td class="memTemplParams" colspan="2">template&lt;typename value_type &gt; </td></tr>
<tr class="memitem:a9f4b69d5700c5c0199c7424183b6641f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a9f4b69d5700c5c0199c7424183b6641f">get_rank</a> (std::vector&lt; value_type &gt; eigenvalues, value_type threshold)</td></tr>
<tr class="separator:a9f4b69d5700c5c0199c7424183b6641f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd7420a1dc9b77f4b5854c865539a9d"><td class="memTemplParams" colspan="2">template&lt;typename value_type &gt; </td></tr>
<tr class="memitem:a4fd7420a1dc9b77f4b5854c865539a9d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a4fd7420a1dc9b77f4b5854c865539a9d">get_rank</a> (std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; value_type &gt;&gt; <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a7fcb72d6b1c715ed5d87f93aabf65581">svd_system</a>, value_type threshold)</td></tr>
<tr class="separator:a4fd7420a1dc9b77f4b5854c865539a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fcb72d6b1c715ed5d87f93aabf65581"><td class="memTemplParams" colspan="2">template&lt;typename value_type , typename std::enable_if_t&lt;!is_complex&lt; value_type &gt;{}, std::nullptr_t &gt;  = nullptr&gt; </td></tr>
<tr class="memitem:a7fcb72d6b1c715ed5d87f93aabf65581"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a7fcb72d6b1c715ed5d87f93aabf65581">svd_system</a> (size_t nrows, size_t ncols, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; value_type &gt; &amp;m, double threshold, bool hermitian=false, bool reduce_to_rank=false)</td></tr>
<tr class="memdesc:a7fcb72d6b1c715ed5d87f93aabf65581"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs singular value decomposition and returns <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html" title="Stores a singular value and corresponding left and right singular vectors.">SVD</a> objects for singular values less than threshold, sorted in ascending order.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a7fcb72d6b1c715ed5d87f93aabf65581">More...</a><br /></td></tr>
<tr class="separator:a7fcb72d6b1c715ed5d87f93aabf65581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c8c4790146512e2ce34c7c45432411"><td class="memTemplParams" colspan="2">template&lt;typename value_type &gt; </td></tr>
<tr class="memitem:ae7c8c4790146512e2ce34c7c45432411"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ae7c8c4790146512e2ce34c7c45432411">printMatrix</a> (const std::vector&lt; value_type &gt; &amp;, size_t rows, size_t cols, std::string title=&quot;&quot;, std::ostream &amp;s=molpro::cout)</td></tr>
<tr class="separator:ae7c8c4790146512e2ce34c7c45432411"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab208f9a750c62cbce299278984d87118"><td class="memTemplParams" colspan="2">template&lt;typename value_type , typename std::enable_if_t&lt; is_complex&lt; value_type &gt;{}, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ab208f9a750c62cbce299278984d87118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab208f9a750c62cbce299278984d87118">eigenproblem</a> (std::vector&lt; value_type &gt; &amp;eigenvectors, std::vector&lt; value_type &gt; &amp;eigenvalues, const std::vector&lt; value_type &gt; &amp;matrix, const std::vector&lt; value_type &gt; &amp;metric, size_t dimension, bool hermitian, double svdThreshold, int verbosity, bool condone_complex)</td></tr>
<tr class="separator:ab208f9a750c62cbce299278984d87118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ef28cdc50441ca2668d749086a6805d"><td class="memTemplParams" colspan="2">template&lt;typename value_type , typename std::enable_if_t&lt; is_complex&lt; value_type &gt;{}, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:a8ef28cdc50441ca2668d749086a6805d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a8ef28cdc50441ca2668d749086a6805d">solve_LinearEquations</a> (std::vector&lt; value_type &gt; &amp;solution, std::vector&lt; value_type &gt; &amp;eigenvalues, const std::vector&lt; value_type &gt; &amp;matrix, const std::vector&lt; value_type &gt; &amp;metric, const std::vector&lt; value_type &gt; &amp;rhs, size_t dimension, size_t nroot, double augmented_hessian, double svdThreshold, int verbosity)</td></tr>
<tr class="separator:a8ef28cdc50441ca2668d749086a6805d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96fd396113d6611510fc4d99c26d706"><td class="memTemplParams" colspan="2">template&lt;typename value_type , typename std::enable_if_t&lt; is_complex&lt; value_type &gt;{}, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:aa96fd396113d6611510fc4d99c26d706"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aa96fd396113d6611510fc4d99c26d706">solve_DIIS</a> (std::vector&lt; value_type &gt; &amp;solution, const std::vector&lt; value_type &gt; &amp;matrix, size_t dimension, double svdThreshold, int verbosity=0)</td></tr>
<tr class="separator:aa96fd396113d6611510fc4d99c26d706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ef971868a57bfead245c92f65cd675"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a42ef971868a57bfead245c92f65cd675">printMatrix&lt; double &gt;</a> (const std::vector&lt; double &gt; &amp;, size_t rows, size_t cols, std::string title, std::ostream &amp;s)</td></tr>
<tr class="separator:a42ef971868a57bfead245c92f65cd675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f02f3120e79df5830593bfef1597ce1"><td class="memItemLeft" align="right" valign="top">template std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a1f02f3120e79df5830593bfef1597ce1">svd_system</a> (size_t nrows, size_t ncols, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; double &gt; &amp;m, double threshold, bool hermitian, bool reduce_to_rank)</td></tr>
<tr class="separator:a1f02f3120e79df5830593bfef1597ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d40717e8aef489ee43e450fa06ee04b"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a4d40717e8aef489ee43e450fa06ee04b">eigenproblem&lt; double &gt;</a> (std::vector&lt; double &gt; &amp;eigenvectors, std::vector&lt; double &gt; &amp;eigenvalues, const std::vector&lt; double &gt; &amp;matrix, const std::vector&lt; double &gt; &amp;metric, const size_t dimension, bool hermitian, double svdThreshold, int verbosity, bool condone_complex)</td></tr>
<tr class="separator:a4d40717e8aef489ee43e450fa06ee04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa62cc2cf48964869a1ef3a69c067d23d"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aa62cc2cf48964869a1ef3a69c067d23d">solve_LinearEquations&lt; double &gt;</a> (std::vector&lt; double &gt; &amp;solution, std::vector&lt; double &gt; &amp;eigenvalues, const std::vector&lt; double &gt; &amp;matrix, const std::vector&lt; double &gt; &amp;metric, const std::vector&lt; double &gt; &amp;rhs, size_t dimension, size_t nroot, double augmented_hessian, double svdThreshold, int verbosity)</td></tr>
<tr class="separator:aa62cc2cf48964869a1ef3a69c067d23d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e048db156aa54f2ee42f5cd169f154f"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a6e048db156aa54f2ee42f5cd169f154f">solve_DIIS&lt; double &gt;</a> (std::vector&lt; double &gt; &amp;solution, const std::vector&lt; double &gt; &amp;matrix, const size_t dimension, double svdThreshold, int verbosity)</td></tr>
<tr class="separator:a6e048db156aa54f2ee42f5cd169f154f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77b36e44914a948846ae34009d81e7a2"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a77b36e44914a948846ae34009d81e7a2">printMatrix&lt; std::complex&lt; double &gt; &gt;</a> (const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;, size_t rows, size_t cols, std::string title, std::ostream &amp;s)</td></tr>
<tr class="separator:a77b36e44914a948846ae34009d81e7a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff8735bcdcf4e8bcd2dd79c785a496f"><td class="memItemLeft" align="right" valign="top">template std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; std::complex&lt; double &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aeff8735bcdcf4e8bcd2dd79c785a496f">svd_system</a> (size_t nrows, size_t ncols, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; std::complex&lt; double &gt;&gt; &amp;m, double threshold, bool hermitian, bool reduce_to_rank)</td></tr>
<tr class="separator:aeff8735bcdcf4e8bcd2dd79c785a496f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce4800c2d1697fe6ccb6a17f8a4b673"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a1ce4800c2d1697fe6ccb6a17f8a4b673">eigenproblem&lt; std::complex&lt; double &gt; &gt;</a> (std::vector&lt; std::complex&lt; double &gt;&gt; &amp;eigenvectors, std::vector&lt; std::complex&lt; double &gt;&gt; &amp;eigenvalues, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;matrix, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;metric, const size_t dimension, bool hermitian, double svdThreshold, int verbosity, bool condone_complex)</td></tr>
<tr class="separator:a1ce4800c2d1697fe6ccb6a17f8a4b673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef5d73cd47e41e8bef02926a21edbf09"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aef5d73cd47e41e8bef02926a21edbf09">solve_LinearEquations&lt; std::complex&lt; double &gt; &gt;</a> (std::vector&lt; std::complex&lt; double &gt;&gt; &amp;solution, std::vector&lt; std::complex&lt; double &gt;&gt; &amp;eigenvalues, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;matrix, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;metric, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;rhs, size_t dimension, size_t nroot, double augmented_hessian, double svdThreshold, int verbosity)</td></tr>
<tr class="separator:aef5d73cd47e41e8bef02926a21edbf09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada97167fc4f0639526c1eb5065b5e367"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ada97167fc4f0639526c1eb5065b5e367">solve_DIIS&lt; std::complex&lt; double &gt; &gt;</a> (std::vector&lt; std::complex&lt; double &gt;&gt; &amp;solution, const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;matrix, const size_t dimension, double svdThreshold, int verbosity)</td></tr>
<tr class="separator:ada97167fc4f0639526c1eb5065b5e367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af378a79765efdce0eb4d198f0ddbe2d1"><td class="memTemplParams" colspan="2">template&lt;typename R , typename Q , typename P &gt; </td></tr>
<tr class="memitem:af378a79765efdce0eb4d198f0ddbe2d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#af378a79765efdce0eb4d198f0ddbe2d1">read_handler_counts</a> (std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &gt; stats, std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; handlers)</td></tr>
<tr class="separator:af378a79765efdce0eb4d198f0ddbe2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c7f04dbdf8dc2a0db7e0eac486817d"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a47c7f04dbdf8dc2a0db7e0eac486817d">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &amp;statistics)</td></tr>
<tr class="separator:a47c7f04dbdf8dc2a0db7e0eac486817d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8229dae1b2c144af940193d4aae8a460"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;std::is_base_of&lt;molpro::linalg::array::DistrArray, T&gt;::value&gt;&gt; </td></tr>
<tr class="memitem:a8229dae1b2c144af940193d4aae8a460"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a8229dae1b2c144af940193d4aae8a460">precondition_default</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; T &gt; &amp;action, const std::vector&lt; double &gt; &amp;shift, const T &amp;diagonals)</td></tr>
<tr class="separator:a8229dae1b2c144af940193d4aae8a460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa196d0f83c9368c7afbb70fec5609c84"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa196d0f83c9368c7afbb70fec5609c84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aa196d0f83c9368c7afbb70fec5609c84">precondition_default</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; T &gt; &amp;action, const std::vector&lt; double &gt; &amp;shift, const T &amp;diagonals, typename T::iterator *=nullptr)</td></tr>
<tr class="separator:aa196d0f83c9368c7afbb70fec5609c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87291e93a2c4e59b1af5b46cdb7d2db6"><td class="memTemplParams" colspan="2">template&lt;typename T , typename  = std::enable_if_t&lt;!std::is_base_of&lt;molpro::linalg::array::DistrArray, T&gt;::value&gt;, class  = void&gt; </td></tr>
<tr class="memitem:a87291e93a2c4e59b1af5b46cdb7d2db6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a87291e93a2c4e59b1af5b46cdb7d2db6">precondition_default</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; T &gt; &amp;action, const std::vector&lt; double &gt; &amp;shift, const T &amp;diagonals, typename std::enable_if&lt;!<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1has__iterator.html">has_iterator</a>&lt; T &gt;::value, void * &gt;::type=nullptr)</td></tr>
<tr class="separator:a87291e93a2c4e59b1af5b46cdb7d2db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d650904c9a8f16d1ad6b8f2d3b766d5"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:a7d650904c9a8f16d1ad6b8f2d3b766d5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a7d650904c9a8f16d1ad6b8f2d3b766d5">wrap</a> (ForwardIt begin, ForwardIt end)</td></tr>
<tr class="memdesc:a7d650904c9a8f16d1ad6b8f2d3b766d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a begin and end iterators and returns a vector of references to each element.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a7d650904c9a8f16d1ad6b8f2d3b766d5">More...</a><br /></td></tr>
<tr class="separator:a7d650904c9a8f16d1ad6b8f2d3b766d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2d191cfa0553d457a8277619c82f930"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:ab2d191cfa0553d457a8277619c82f930"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab2d191cfa0553d457a8277619c82f930">const_cast_wrap</a> (ForwardIt begin, ForwardIt end)</td></tr>
<tr class="memdesc:ab2d191cfa0553d457a8277619c82f930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a begin and end iterators and returns a vector of const-casted references to each element.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#ab2d191cfa0553d457a8277619c82f930">More...</a><br /></td></tr>
<tr class="separator:ab2d191cfa0553d457a8277619c82f930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15fcd8807dbc5342d69f6be91d7a17b5"><td class="memTemplParams" colspan="2">template&lt;class ForwardIt &gt; </td></tr>
<tr class="memitem:a15fcd8807dbc5342d69f6be91d7a17b5"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a15fcd8807dbc5342d69f6be91d7a17b5">cwrap</a> (ForwardIt begin, ForwardIt end)</td></tr>
<tr class="memdesc:a15fcd8807dbc5342d69f6be91d7a17b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a begin and end iterators and returns a vector of references to each element.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a15fcd8807dbc5342d69f6be91d7a17b5">More...</a><br /></td></tr>
<tr class="separator:a15fcd8807dbc5342d69f6be91d7a17b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad9256532df6a4b245a3679328edc1d"><td class="memTemplParams" colspan="2">template&lt;class IterableContainer &gt; </td></tr>
<tr class="memitem:a7ad9256532df6a4b245a3679328edc1d"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a7ad9256532df6a4b245a3679328edc1d">wrap</a> (const IterableContainer &amp;parameters)</td></tr>
<tr class="memdesc:a7ad9256532df6a4b245a3679328edc1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps references for each parameter in an iterable container that implements begin()/end()  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a7ad9256532df6a4b245a3679328edc1d">More...</a><br /></td></tr>
<tr class="separator:a7ad9256532df6a4b245a3679328edc1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37643fbaca3b182e357855888611778"><td class="memTemplParams" colspan="2">template&lt;class IterableContainer &gt; </td></tr>
<tr class="memitem:ae37643fbaca3b182e357855888611778"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ae37643fbaca3b182e357855888611778">wrap</a> (IterableContainer &amp;parameters)</td></tr>
<tr class="memdesc:ae37643fbaca3b182e357855888611778"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps references for each parameter in an iterable container that implements begin()/end()  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#ae37643fbaca3b182e357855888611778">More...</a><br /></td></tr>
<tr class="separator:ae37643fbaca3b182e357855888611778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81d731957693dbb73bc153797a651c8f"><td class="memTemplParams" colspan="2">template&lt;class IterableContainer &gt; </td></tr>
<tr class="memitem:a81d731957693dbb73bc153797a651c8f"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a81d731957693dbb73bc153797a651c8f">const_cast_wrap</a> (IterableContainer &amp;parameters)</td></tr>
<tr class="memdesc:a81d731957693dbb73bc153797a651c8f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps const-casted references for each parameter in an iterable container that implements begin()/end()  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a81d731957693dbb73bc153797a651c8f">More...</a><br /></td></tr>
<tr class="separator:a81d731957693dbb73bc153797a651c8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676d330a22092146b7c63d7f60170973"><td class="memTemplParams" colspan="2">template&lt;class IterableContainer &gt; </td></tr>
<tr class="memitem:a676d330a22092146b7c63d7f60170973"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a676d330a22092146b7c63d7f60170973">cwrap</a> (IterableContainer &amp;parameters)</td></tr>
<tr class="memdesc:a676d330a22092146b7c63d7f60170973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wraps references for each parameter in an iterable container that implements begin()/end()  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a676d330a22092146b7c63d7f60170973">More...</a><br /></td></tr>
<tr class="separator:a676d330a22092146b7c63d7f60170973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e22e4990cb5176be5f6473bd0944ec0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... S&gt; </td></tr>
<tr class="memitem:a8e22e4990cb5176be5f6473bd0944ec0"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a8e22e4990cb5176be5f6473bd0944ec0">wrap_arg</a> (T &amp;&amp;arg, S &amp;&amp;... args) -&gt; std::enable_if_t&lt; std::conjunction_v&lt; std::is_same&lt; <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt; T &gt;, <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt; S &gt;&gt;... &gt;, <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt; T &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a8e22e4990cb5176be5f6473bd0944ec0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector of reference wrappers with provided arguments.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a8e22e4990cb5176be5f6473bd0944ec0">More...</a><br /></td></tr>
<tr class="separator:a8e22e4990cb5176be5f6473bd0944ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12422cdb3f57b1496639dedc57bf70a1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... S&gt; </td></tr>
<tr class="memitem:a12422cdb3f57b1496639dedc57bf70a1"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a12422cdb3f57b1496639dedc57bf70a1">cwrap_arg</a> (T &amp;&amp;arg, S &amp;&amp;... args) -&gt; std::enable_if_t&lt; std::conjunction_v&lt; std::is_same&lt; <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt; T &gt;, <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt; S &gt;&gt;... &gt;, <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt; T &gt;&gt;&gt;</td></tr>
<tr class="memdesc:a12422cdb3f57b1496639dedc57bf70a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a vector of const reference wrappers with provided arguments.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a12422cdb3f57b1496639dedc57bf70a1">More...</a><br /></td></tr>
<tr class="separator:a12422cdb3f57b1496639dedc57bf70a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aef8796e9dc52fed775e88ca4d61bf3"><td class="memTemplParams" colspan="2">template&lt;typename R , typename ForwardIt &gt; </td></tr>
<tr class="memitem:a1aef8796e9dc52fed775e88ca4d61bf3"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a1aef8796e9dc52fed775e88ca4d61bf3">find_ref</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;wparams, ForwardIt begin, ForwardIt end)</td></tr>
<tr class="memdesc:a1aef8796e9dc52fed775e88ca4d61bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given wrapped references in wparams and a range of original parameters [begin, end), returns indices of parameters that are wrapped in this range.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a1aef8796e9dc52fed775e88ca4d61bf3">More...</a><br /></td></tr>
<tr class="separator:a1aef8796e9dc52fed775e88ca4d61bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f278e2194366576a3529180797ee4e4"><td class="memTemplParams" colspan="2">template&lt;typename R &gt; </td></tr>
<tr class="memitem:a4f278e2194366576a3529180797ee4e4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a4f278e2194366576a3529180797ee4e4">find_ref</a> (const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;wparams, const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;wparams_ref)</td></tr>
<tr class="memdesc:a4f278e2194366576a3529180797ee4e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given two wrapped references returns indices of parameters that are in both sets.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#a4f278e2194366576a3529180797ee4e4">More...</a><br /></td></tr>
<tr class="separator:a4f278e2194366576a3529180797ee4e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2245800026088096803c477ba48f674"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa2245800026088096803c477ba48f674"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aa2245800026088096803c477ba48f674">remove_elements</a> (std::vector&lt; T &gt; params, const std::vector&lt; U &gt; &amp;indices)</td></tr>
<tr class="memdesc:aa2245800026088096803c477ba48f674"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes indices from a vector.  <a href="namespacemolpro_1_1linalg_1_1itsolv.html#aa2245800026088096803c477ba48f674">More...</a><br /></td></tr>
<tr class="separator:aa2245800026088096803c477ba48f674"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3a866047f77f57c53f1e30ee1ef89a"><td class="memTemplParams" colspan="2">template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </td></tr>
<tr class="memitem:aeb3a866047f77f57c53f1e30ee1ef89a"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>&lt; R, Q, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aeb3a866047f77f57c53f1e30ee1ef89a">create_LinearEigensystem</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemOptions.html">LinearEigensystemOptions</a> &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>, const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;())</td></tr>
<tr class="separator:aeb3a866047f77f57c53f1e30ee1ef89a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41d8dbaac0687f2ff998e77bf01f9b81"><td class="memTemplParams" colspan="2">template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </td></tr>
<tr class="memitem:a41d8dbaac0687f2ff998e77bf01f9b81"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>&lt; R, Q, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a41d8dbaac0687f2ff998e77bf01f9b81">create_LinearEigensystem</a> (const std::string &amp;method=&quot;Davidson&quot;, const std::string &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>=&quot;&quot;, const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;())</td></tr>
<tr class="separator:a41d8dbaac0687f2ff998e77bf01f9b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fba9ad2b233fc203e32fa8ce24c08c"><td class="memTemplParams" colspan="2">template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </td></tr>
<tr class="memitem:aa4fba9ad2b233fc203e32fa8ce24c08c"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEquations.html">LinearEquations</a>&lt; R, Q, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aa4fba9ad2b233fc203e32fa8ce24c08c">create_LinearEquations</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEquationsOptions.html">LinearEquationsOptions</a> &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>, const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;())</td></tr>
<tr class="separator:aa4fba9ad2b233fc203e32fa8ce24c08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d5efb7e5a2f9b8b0eb68458d4829c5"><td class="memTemplParams" colspan="2">template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </td></tr>
<tr class="memitem:a37d5efb7e5a2f9b8b0eb68458d4829c5"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEquations.html">LinearEquations</a>&lt; R, Q, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a37d5efb7e5a2f9b8b0eb68458d4829c5">create_LinearEquations</a> (const std::string &amp;method=&quot;Davidson&quot;, const std::string &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>=&quot;&quot;, const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;())</td></tr>
<tr class="separator:a37d5efb7e5a2f9b8b0eb68458d4829c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44c9dd1bc04c3af30529772a4e1a0fc"><td class="memTemplParams" colspan="2">template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </td></tr>
<tr class="memitem:ae44c9dd1bc04c3af30529772a4e1a0fc"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquations.html">NonLinearEquations</a>&lt; R, Q, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ae44c9dd1bc04c3af30529772a4e1a0fc">create_NonLinearEquations</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquationsOptions.html">NonLinearEquationsOptions</a> &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>=<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquationsOptions.html">NonLinearEquationsOptions</a>{}, const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;())</td></tr>
<tr class="separator:ae44c9dd1bc04c3af30529772a4e1a0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf919552de3b27d093f581f8687607b"><td class="memTemplParams" colspan="2">template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </td></tr>
<tr class="memitem:abdf919552de3b27d093f581f8687607b"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquations.html">NonLinearEquations</a>&lt; R, Q, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#abdf919552de3b27d093f581f8687607b">create_NonLinearEquations</a> (const std::string &amp;method=&quot;DIIS&quot;, const std::string &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>=&quot;&quot;, const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;())</td></tr>
<tr class="separator:abdf919552de3b27d093f581f8687607b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eb174bad1305a5127594f7bc8d13e7f"><td class="memTemplParams" colspan="2">template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </td></tr>
<tr class="memitem:a2eb174bad1305a5127594f7bc8d13e7f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Optimize.html">Optimize</a>&lt; R, Q, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2eb174bad1305a5127594f7bc8d13e7f">create_Optimize</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeOptions.html">OptimizeOptions</a> &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>=<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeOptions.html">OptimizeOptions</a>{}, const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;())</td></tr>
<tr class="separator:a2eb174bad1305a5127594f7bc8d13e7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab41126649ca60e3a58ff9d7a607765ba"><td class="memTemplParams" colspan="2">template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </td></tr>
<tr class="memitem:ab41126649ca60e3a58ff9d7a607765ba"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Optimize.html">Optimize</a>&lt; R, Q, P &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab41126649ca60e3a58ff9d7a607765ba">create_Optimize</a> (const std::string &amp;method=&quot;BFGS&quot;, const std::string &amp;<a class="el" href="namespacemolpro_1_1linalg.html#abd04a7feed3604605815d55678fc2369">options</a>=&quot;&quot;, const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;handlers=std::make_shared&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt; R, Q, P &gt;&gt;())</td></tr>
<tr class="separator:ab41126649ca60e3a58ff9d7a607765ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad845d8e72c3518d938b7c0250c70de87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ad845d8e72c3518d938b7c0250c70de87">operator==</a> (const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Interpolate_1_1point.html">Interpolate::point</a> &amp;lhs, const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Interpolate_1_1point.html">Interpolate::point</a> &amp;rhs)</td></tr>
<tr class="separator:ad845d8e72c3518d938b7c0250c70de87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34716bbff9ede5e99934fba56f2f4f4b"><td class="memTemplParams" colspan="2">template&lt;typename value_type &gt; </td></tr>
<tr class="memitem:a34716bbff9ede5e99934fba56f2f4f4b"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a34716bbff9ede5e99934fba56f2f4f4b">svd_eigen_jacobi</a> (size_t nrows, size_t ncols, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; value_type &gt; &amp;m, double threshold)</td></tr>
<tr class="separator:a34716bbff9ede5e99934fba56f2f4f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e3335c9b5ce4efb8b41ab8627b3bd6"><td class="memTemplParams" colspan="2">template&lt;typename value_type &gt; </td></tr>
<tr class="memitem:a06e3335c9b5ce4efb8b41ab8627b3bd6"><td class="memTemplItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; value_type &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a06e3335c9b5ce4efb8b41ab8627b3bd6">svd_eigen_bdcsvd</a> (size_t nrows, size_t ncols, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; value_type &gt; &amp;m, double threshold)</td></tr>
<tr class="separator:a06e3335c9b5ce4efb8b41ab8627b3bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae03ed5424809a945ea8755ea935e65a3"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ae03ed5424809a945ea8755ea935e65a3">printMatrix&lt; value_type &gt;</a> (const std::vector&lt; value_type &gt; &amp;, size_t rows, size_t cols, std::string title, std::ostream &amp;s)</td></tr>
<tr class="separator:ae03ed5424809a945ea8755ea935e65a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee90b05dcbb6a130dd3a37de50dabce"><td class="memItemLeft" align="right" valign="top">template size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a7ee90b05dcbb6a130dd3a37de50dabce">get_rank&lt; value_type &gt;</a> (std::vector&lt; value_type &gt; eigenvalues, value_type threshold)</td></tr>
<tr class="separator:a7ee90b05dcbb6a130dd3a37de50dabce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7117e36c19daa3142245f1493a5fb8f"><td class="memItemLeft" align="right" valign="top">template std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; value_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab7117e36c19daa3142245f1493a5fb8f">svd_system&lt; value_type &gt;</a> (size_t nrows, size_t ncols, const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; value_type &gt; &amp;m, double threshold, bool hermitian, bool reduce_to_rank)</td></tr>
<tr class="separator:ab7117e36c19daa3142245f1493a5fb8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4c7295faf87794ff06f76866fbe3ca"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a6a4c7295faf87794ff06f76866fbe3ca">eigenproblem&lt; value_type &gt;</a> (std::vector&lt; value_type &gt; &amp;eigenvectors, std::vector&lt; value_type &gt; &amp;eigenvalues, const std::vector&lt; value_type &gt; &amp;matrix, const std::vector&lt; value_type &gt; &amp;metric, size_t dimension, bool hermitian, double svdThreshold, int verbosity, bool condone_complex)</td></tr>
<tr class="separator:a6a4c7295faf87794ff06f76866fbe3ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5346e25e508bbda87664acdfd3b029f"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ad5346e25e508bbda87664acdfd3b029f">solve_LinearEquations&lt; value_type &gt;</a> (std::vector&lt; value_type &gt; &amp;solution, std::vector&lt; value_type &gt; &amp;eigenvalues, const std::vector&lt; value_type &gt; &amp;matrix, const std::vector&lt; value_type &gt; &amp;metric, const std::vector&lt; value_type &gt; &amp;rhs, size_t dimension, size_t nroot, double augmented_hessian, double svdThreshold, int verbosity)</td></tr>
<tr class="separator:ad5346e25e508bbda87664acdfd3b029f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf2f13f0106989d610fa4b05ce05eee"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#abdf2f13f0106989d610fa4b05ce05eee">solve_DIIS&lt; value_type &gt;</a> (std::vector&lt; value_type &gt; &amp;solution, const std::vector&lt; value_type &gt; &amp;matrix, size_t dimension, double svdThreshold, int verbosity)</td></tr>
<tr class="separator:abdf2f13f0106989d610fa4b05ce05eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>4-parameter interpolation of a 1-dimensional function given two points for which function values and first derivatives are known. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aafd1821a97ea122d56be347e38e90a89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd1821a97ea122d56be347e38e90a89">&#9670;&nbsp;</a></span>CVecRef</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">molpro::linalg::itsolv::CVecRef</a> = typedef std::vector&lt;std::reference_wrapper&lt;const A&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2541a0dfd2575a25a8d4976899b63e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2541a0dfd2575a25a8d4976899b63e1d">&#9670;&nbsp;</a></span>decay_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">molpro::linalg::itsolv::decay_t</a> = typedef typename <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1decay.html">decay</a>&lt;T&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a784351a2599ca33773a9809818edb5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784351a2599ca33773a9809818edb5a1">&#9670;&nbsp;</a></span>options_map</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a784351a2599ca33773a9809818edb5a1">molpro::linalg::itsolv::options_map</a> = typedef std::map&lt;std::string, std::string&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab44c7c7dfce88d39d260d1f5c7b70fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab44c7c7dfce88d39d260d1f5c7b70fab">&#9670;&nbsp;</a></span>VecRef</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">molpro::linalg::itsolv::VecRef</a> = typedef std::vector&lt;std::reference_wrapper&lt;A&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ac8246e59286ac3630c4c80231d6ed172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8246e59286ac3630c4c80231d6ed172">&#9670;&nbsp;</a></span>Verbosity</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ac8246e59286ac3630c4c80231d6ed172">molpro::linalg::itsolv::Verbosity</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Specifies how much detail <code><a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1IterativeSolver.html#a527854d92a5f67f6bee487f46ea02524" title="Simplified one-call solver.">IterativeSolver::solve</a></code> should write to output. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac8246e59286ac3630c4c80231d6ed172a6adf97f83acf6453d4a6a4b1070f3754"></a>None&#160;</td><td class="fielddoc"><p>no output </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8246e59286ac3630c4c80231d6ed172a290612199861c31d1036b185b4e69b75"></a>Summary&#160;</td><td class="fielddoc"><p>only summary at the start and end of solve </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8246e59286ac3630c4c80231d6ed172a86c1e32c05338b57578313d8a6fa892d"></a>Iteration&#160;</td><td class="fielddoc"><p>Summary plus minimal results at each iteration. </p>
</td></tr>
<tr><td class="fieldname"><a id="ac8246e59286ac3630c4c80231d6ed172a4042fcadbe61a3300451157e2c9fe651"></a>Detailed&#160;</td><td class="fielddoc"><p>Iteration plus more detail such as operation count. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab2d191cfa0553d457a8277619c82f930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2d191cfa0553d457a8277619c82f930">&#9670;&nbsp;</a></span>const_cast_wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::const_cast_wrap </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a begin and end iterators and returns a vector of const-casted references to each element. </p>

</div>
</div>
<a id="a81d731957693dbb73bc153797a651c8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d731957693dbb73bc153797a651c8f">&#9670;&nbsp;</a></span>const_cast_wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterableContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::const_cast_wrap </td>
          <td>(</td>
          <td class="paramtype">IterableContainer &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps const-casted references for each parameter in an iterable container that implements begin()/end() </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterableContainer</td><td>should have begin()/end() either as free or member functions </td></tr>
    <tr><td class="paramname">R</td><td>element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>parameters to wrap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of references to each element in parameters </dd></dl>

</div>
</div>
<a id="aeb3a866047f77f57c53f1e30ee1ef89a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3a866047f77f57c53f1e30ee1ef89a">&#9670;&nbsp;</a></span>create_LinearEigensystem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>&lt;R, Q, P&gt; &gt; molpro::linalg::itsolv::create_LinearEigensystem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystemOptions.html">LinearEigensystemOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a41d8dbaac0687f2ff998e77bf01f9b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41d8dbaac0687f2ff998e77bf01f9b81">&#9670;&nbsp;</a></span>create_LinearEigensystem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEigensystem.html">LinearEigensystem</a>&lt;R, Q, P&gt; &gt; molpro::linalg::itsolv::create_LinearEigensystem </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;Davidson&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4fba9ad2b233fc203e32fa8ce24c08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fba9ad2b233fc203e32fa8ce24c08c">&#9670;&nbsp;</a></span>create_LinearEquations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEquations.html">LinearEquations</a>&lt;R, Q, P&gt; &gt; molpro::linalg::itsolv::create_LinearEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1LinearEquationsOptions.html">LinearEquationsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37d5efb7e5a2f9b8b0eb68458d4829c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d5efb7e5a2f9b8b0eb68458d4829c5">&#9670;&nbsp;</a></span>create_LinearEquations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1LinearEquations.html">LinearEquations</a>&lt;R, Q, P&gt; &gt; molpro::linalg::itsolv::create_LinearEquations </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;Davidson&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae44c9dd1bc04c3af30529772a4e1a0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44c9dd1bc04c3af30529772a4e1a0fc">&#9670;&nbsp;</a></span>create_NonLinearEquations() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquations.html">NonLinearEquations</a>&lt;R, Q, P&gt; &gt; molpro::linalg::itsolv::create_NonLinearEquations </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquationsOptions.html">NonLinearEquationsOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquationsOptions.html">NonLinearEquationsOptions</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdf919552de3b27d093f581f8687607b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf919552de3b27d093f581f8687607b">&#9670;&nbsp;</a></span>create_NonLinearEquations() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1NonLinearEquations.html">NonLinearEquations</a>&lt;R, Q, P&gt; &gt; molpro::linalg::itsolv::create_NonLinearEquations </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;DIIS&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2eb174bad1305a5127594f7bc8d13e7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eb174bad1305a5127594f7bc8d13e7f">&#9670;&nbsp;</a></span>create_Optimize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Optimize.html">Optimize</a>&lt;R, Q, P&gt; &gt; molpro::linalg::itsolv::create_Optimize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeOptions.html">OptimizeOptions</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code><a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1OptimizeOptions.html">OptimizeOptions</a>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab41126649ca60e3a58ff9d7a607765ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab41126649ca60e3a58ff9d7a607765ba">&#9670;&nbsp;</a></span>create_Optimize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class R , class Q  = R, class P  = std::map&lt;size_t, typename R::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1Optimize.html">Optimize</a>&lt;R, Q, P&gt; &gt; molpro::linalg::itsolv::create_Optimize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>method</em> = <code>&quot;BFGS&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>options</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>handlers</em> = <code>std::make_shared&lt;<a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">molpro::linalg::itsolv::ArrayHandlers</a>&lt;R,&#160;Q,&#160;P&gt;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15fcd8807dbc5342d69f6be91d7a17b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fcd8807dbc5342d69f6be91d7a17b5">&#9670;&nbsp;</a></span>cwrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::cwrap </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a begin and end iterators and returns a vector of references to each element. </p>

</div>
</div>
<a id="a676d330a22092146b7c63d7f60170973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676d330a22092146b7c63d7f60170973">&#9670;&nbsp;</a></span>cwrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterableContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::cwrap </td>
          <td>(</td>
          <td class="paramtype">IterableContainer &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps references for each parameter in an iterable container that implements begin()/end() </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterableContainer</td><td>should have begin()/end() either as free or member functions </td></tr>
    <tr><td class="paramname">R</td><td>element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>parameters to wrap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of constant references to each element in parameters </dd></dl>

</div>
</div>
<a id="a12422cdb3f57b1496639dedc57bf70a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12422cdb3f57b1496639dedc57bf70a1">&#9670;&nbsp;</a></span>cwrap_arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::cwrap_arg </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;std::conjunction_v&lt;std::is_same&lt;<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt;T&gt;, <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt;S&gt;&gt;...&gt;, <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt;<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt;T&gt;&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a vector of const reference wrappers with provided arguments. </p>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="LinearEquationsExample_8cpp-example.html#a2">LinearEquationsExample.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ab208f9a750c62cbce299278984d87118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab208f9a750c62cbce299278984d87118">&#9670;&nbsp;</a></span>eigenproblem()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type , typename std::enable_if_t&lt; is_complex&lt; value_type &gt;{}, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void molpro::linalg::itsolv::eigenproblem </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condone_complex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d40717e8aef489ee43e450fa06ee04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d40717e8aef489ee43e450fa06ee04b">&#9670;&nbsp;</a></span>eigenproblem&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab208f9a750c62cbce299278984d87118">molpro::linalg::itsolv::eigenproblem</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condone_complex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ce4800c2d1697fe6ccb6a17f8a4b673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce4800c2d1697fe6ccb6a17f8a4b673">&#9670;&nbsp;</a></span>eigenproblem&lt; std::complex&lt; double &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab208f9a750c62cbce299278984d87118">molpro::linalg::itsolv::eigenproblem</a>&lt; std::complex&lt; double &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condone_complex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6a4c7295faf87794ff06f76866fbe3ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4c7295faf87794ff06f76866fbe3ca">&#9670;&nbsp;</a></span>eigenproblem&lt; value_type &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab208f9a750c62cbce299278984d87118">molpro::linalg::itsolv::eigenproblem</a>&lt; value_type &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condone_complex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac08926114067c3eafad9a758df73dabc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08926114067c3eafad9a758df73dabc">&#9670;&nbsp;</a></span>eigensolver_lapacke_dsyev() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int molpro::linalg::itsolv::eigensolver_lapacke_dsyev </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper function for lapacke_dsyev (linear eigensystem solver) from the lapack C interface (lapacke.h). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>the input matrix (will not be altered!). Must be square. Must be dimension*dimension elements long. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvectors</td><td>the matrix of eigenvectors, row major ordering. Must be square and the same size as matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">eigenvalues</td><td>a list of eigenvalues. Must be the length specified by the 'dimension' parameter. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimension</td><td>length of one axis of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>status. If 0, successful exit. If -i, the ith argument had an illegal value. If i, the algorithm failed to converge. </dd></dl>

</div>
</div>
<a id="a516f42ae956054880e6649b626657478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a516f42ae956054880e6649b626657478">&#9670;&nbsp;</a></span>eigensolver_lapacke_dsyev() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; double &gt; &gt; molpro::linalg::itsolv::eigensolver_lapacke_dsyev </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">molpro::linalg::array::span::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper function for lapacke_dsyev (linear eigensystem solver) from the lapack C interface (lapacke.h). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dimension</td><td>length of one axis of the matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>a span wrapping some data structure containing the elements of the matrix. Should be dimension*dimension in length. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::list of instances of <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html" title="Stores a singular value and corresponding left and right singular vectors.">SVD</a>, a struct containing one eigenvalue and one eigenvector. For a real, symmetric matrix, these are equivalent to singular values, and S/D (which are both the same). </dd></dl>

</div>
</div>
<a id="a3bdd3fd38d1ba9aa765db3684fb866ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bdd3fd38d1ba9aa765db3684fb866ff">&#9670;&nbsp;</a></span>eigensolver_lapacke_dsyev() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; double &gt; &gt; molpro::linalg::itsolv::eigensolver_lapacke_dsyev </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper function for lapacke_dsyev (linear eigensystem solver) from the lapack C interface (lapacke.h). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">matrix</td><td>the input matrix (will not be altered!). Must be square. Must be dimension*dimension elements long. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dimension</td><td>length of one axis of the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a std::list of instances of <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html" title="Stores a singular value and corresponding left and right singular vectors.">SVD</a>, a struct containing one eigenvalue and one eigenvector. For a real, symmetric matrix, these are equivalent to singular values, and S/D (which are both the same). </dd></dl>

</div>
</div>
<a id="a4f278e2194366576a3529180797ee4e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f278e2194366576a3529180797ee4e4">&#9670;&nbsp;</a></span>find_ref() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; molpro::linalg::itsolv::find_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>wparams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aafd1821a97ea122d56be347e38e90a89">CVecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>wparams_ref</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given two wrapped references returns indices of parameters that are in both sets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wparams</td><td>first set of references </td></tr>
    <tr><td class="paramname">wparams_ref</td><td>second set of references </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1aef8796e9dc52fed775e88ca4d61bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aef8796e9dc52fed775e88ca4d61bf3">&#9670;&nbsp;</a></span>find_ref() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename ForwardIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; molpro::linalg::itsolv::find_ref </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; R &gt; &amp;&#160;</td>
          <td class="paramname"><em>wparams</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given wrapped references in wparams and a range of original parameters [begin, end), returns indices of parameters that are wrapped in this range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wparams</td><td>wrapped references to subset of params </td></tr>
    <tr><td class="paramname">begin</td><td>start of range of original paramaters </td></tr>
    <tr><td class="paramname">end</td><td>end of range of original paramaters </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4fd7420a1dc9b77f4b5854c865539a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd7420a1dc9b77f4b5854c865539a9d">&#9670;&nbsp;</a></span>get_rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t molpro::linalg::itsolv::get_rank </td>
          <td>(</td>
          <td class="paramtype">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>svd_system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the rank of some matrix, given a threshold. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">svd_system</td><td>a std::list containing <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html" title="Stores a singular value and corresponding left and right singular vectors.">SVD</a> objects, such as those created by <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a7fcb72d6b1c715ed5d87f93aabf65581" title="Performs singular value decomposition and returns SVD objects for singular values less than threshold...">itsolv::svd_system</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>the threshold. Note that this is the normalised threshold, a value between 0 and 1, relative to the largest element in the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank. For an empty matrix, returns 0. </dd></dl>

</div>
</div>
<a id="a9f4b69d5700c5c0199c7424183b6641f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f4b69d5700c5c0199c7424183b6641f">&#9670;&nbsp;</a></span>get_rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t molpro::linalg::itsolv::get_rank </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the rank of some matrix, given a threshold. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">eigenvalues</td><td>the matrix, as a vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">threshold</td><td>the threshold. Note that this is the normalised threshold, a value between 0 and 1, relative to the largest element in the matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the rank. For an empty matrix, returns 0. </dd></dl>

</div>
</div>
<a id="a7ee90b05dcbb6a130dd3a37de50dabce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee90b05dcbb6a130dd3a37de50dabce">&#9670;&nbsp;</a></span>get_rank&lt; value_type &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template size_t <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a9f4b69d5700c5c0199c7424183b6641f">molpro::linalg::itsolv::get_rank</a>&lt; value_type &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; value_type &gt;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value_type&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47c7f04dbdf8dc2a0db7e0eac486817d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c7f04dbdf8dc2a0db7e0eac486817d">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; molpro::linalg::itsolv::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>o</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &amp;&#160;</td>
          <td class="paramname"><em>statistics</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad845d8e72c3518d938b7c0250c70de87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad845d8e72c3518d938b7c0250c70de87">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool molpro::linalg::itsolv::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Interpolate_1_1point.html">Interpolate::point</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Interpolate_1_1point.html">Interpolate::point</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8229dae1b2c144af940193d4aae8a460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8229dae1b2c144af940193d4aae8a460">&#9670;&nbsp;</a></span>precondition_default() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;std::is_base_of&lt;molpro::linalg::array::DistrArray, T&gt;::value&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void molpro::linalg::itsolv::precondition_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>diagonals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87291e93a2c4e59b1af5b46cdb7d2db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87291e93a2c4e59b1af5b46cdb7d2db6">&#9670;&nbsp;</a></span>precondition_default() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename  = std::enable_if_t&lt;!std::is_base_of&lt;molpro::linalg::array::DistrArray, T&gt;::value&gt;, class  = void&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void molpro::linalg::itsolv::precondition_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>diagonals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename std::enable_if&lt;!<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1has__iterator.html">has_iterator</a>&lt; T &gt;::value, void * &gt;::type&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa196d0f83c9368c7afbb70fec5609c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa196d0f83c9368c7afbb70fec5609c84">&#9670;&nbsp;</a></span>precondition_default() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void molpro::linalg::itsolv::precondition_default </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>action</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>diagonals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename T::iterator *&#160;</td>
          <td class="paramname"> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7c8c4790146512e2ce34c7c45432411"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7c8c4790146512e2ce34c7c45432411">&#9670;&nbsp;</a></span>printMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void molpro::linalg::itsolv::printMatrix </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>title</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em> = <code>molpro::cout</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42ef971868a57bfead245c92f65cd675"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42ef971868a57bfead245c92f65cd675">&#9670;&nbsp;</a></span>printMatrix&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ae7c8c4790146512e2ce34c7c45432411">molpro::linalg::itsolv::printMatrix</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77b36e44914a948846ae34009d81e7a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77b36e44914a948846ae34009d81e7a2">&#9670;&nbsp;</a></span>printMatrix&lt; std::complex&lt; double &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ae7c8c4790146512e2ce34c7c45432411">molpro::linalg::itsolv::printMatrix</a>&lt; std::complex&lt; double &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae03ed5424809a945ea8755ea935e65a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae03ed5424809a945ea8755ea935e65a3">&#9670;&nbsp;</a></span>printMatrix&lt; value_type &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ae7c8c4790146512e2ce34c7c45432411">molpro::linalg::itsolv::printMatrix</a>&lt; value_type &gt; </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>title</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af378a79765efdce0eb4d198f0ddbe2d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af378a79765efdce0eb4d198f0ddbe2d1">&#9670;&nbsp;</a></span>read_handler_counts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename R , typename Q , typename P &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void molpro::linalg::itsolv::read_handler_counts </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1Statistics.html">Statistics</a> &gt;&#160;</td>
          <td class="paramname"><em>stats</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classmolpro_1_1linalg_1_1itsolv_1_1ArrayHandlers.html">ArrayHandlers</a>&lt; R, Q, P &gt;&gt;&#160;</td>
          <td class="paramname"><em>handlers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2245800026088096803c477ba48f674"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2245800026088096803c477ba48f674">&#9670;&nbsp;</a></span>remove_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::remove_elements </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; T &gt;&#160;</td>
          <td class="paramname"><em>params</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes indices from a vector. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>value type </td></tr>
    <tr><td class="paramname">I</td><td>index type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>container </td></tr>
    <tr><td class="paramname">indices</td><td>indices to remove </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aa96fd396113d6611510fc4d99c26d706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96fd396113d6611510fc4d99c26d706">&#9670;&nbsp;</a></span>solve_DIIS()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type , typename std::enable_if_t&lt; is_complex&lt; value_type &gt;{}, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void molpro::linalg::itsolv::solve_DIIS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e048db156aa54f2ee42f5cd169f154f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e048db156aa54f2ee42f5cd169f154f">&#9670;&nbsp;</a></span>solve_DIIS&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aa96fd396113d6611510fc4d99c26d706">molpro::linalg::itsolv::solve_DIIS</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ada97167fc4f0639526c1eb5065b5e367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada97167fc4f0639526c1eb5065b5e367">&#9670;&nbsp;</a></span>solve_DIIS&lt; std::complex&lt; double &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aa96fd396113d6611510fc4d99c26d706">molpro::linalg::itsolv::solve_DIIS</a>&lt; std::complex&lt; double &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abdf2f13f0106989d610fa4b05ce05eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf2f13f0106989d610fa4b05ce05eee">&#9670;&nbsp;</a></span>solve_DIIS&lt; value_type &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#aa96fd396113d6611510fc4d99c26d706">molpro::linalg::itsolv::solve_DIIS</a>&lt; value_type &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ef28cdc50441ca2668d749086a6805d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ef28cdc50441ca2668d749086a6805d">&#9670;&nbsp;</a></span>solve_LinearEquations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type , typename std::enable_if_t&lt; is_complex&lt; value_type &gt;{}, int &gt;  = 0&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void molpro::linalg::itsolv::solve_LinearEquations </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>augmented_hessian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa62cc2cf48964869a1ef3a69c067d23d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62cc2cf48964869a1ef3a69c067d23d">&#9670;&nbsp;</a></span>solve_LinearEquations&lt; double &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a8ef28cdc50441ca2668d749086a6805d">molpro::linalg::itsolv::solve_LinearEquations</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>augmented_hessian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef5d73cd47e41e8bef02926a21edbf09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef5d73cd47e41e8bef02926a21edbf09">&#9670;&nbsp;</a></span>solve_LinearEquations&lt; std::complex&lt; double &gt; &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a8ef28cdc50441ca2668d749086a6805d">molpro::linalg::itsolv::solve_LinearEquations</a>&lt; std::complex&lt; double &gt; &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>augmented_hessian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5346e25e508bbda87664acdfd3b029f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5346e25e508bbda87664acdfd3b029f">&#9670;&nbsp;</a></span>solve_LinearEquations&lt; value_type &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a8ef28cdc50441ca2668d749086a6805d">molpro::linalg::itsolv::solve_LinearEquations</a>&lt; value_type &gt; </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>eigenvalues</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>metric</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dimension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nroot</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>augmented_hessian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>svdThreshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>verbosity</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06e3335c9b5ce4efb8b41ab8627b3bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e3335c9b5ce4efb8b41ab8627b3bd6">&#9670;&nbsp;</a></span>svd_eigen_bdcsvd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt;value_type&gt; &gt; molpro::linalg::itsolv::svd_eigen_bdcsvd </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34716bbff9ede5e99934fba56f2f4f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34716bbff9ede5e99934fba56f2f4f4b">&#9670;&nbsp;</a></span>svd_eigen_jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt;value_type&gt; &gt; molpro::linalg::itsolv::svd_eigen_jacobi </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f02f3120e79df5830593bfef1597ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f02f3120e79df5830593bfef1597ce1">&#9670;&nbsp;</a></span>svd_system() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::list&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt;double&gt; &gt; molpro::linalg::itsolv::svd_system </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reduce_to_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeff8735bcdcf4e8bcd2dd79c785a496f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff8735bcdcf4e8bcd2dd79c785a496f">&#9670;&nbsp;</a></span>svd_system() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::list&lt;<a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt;std::complex&lt;double&gt; &gt; &gt; molpro::linalg::itsolv::svd_system </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; std::complex&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reduce_to_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fcb72d6b1c715ed5d87f93aabf65581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fcb72d6b1c715ed5d87f93aabf65581">&#9670;&nbsp;</a></span>svd_system() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename value_type , typename std::enable_if_t&lt;!is_complex&lt; value_type &gt;{}, std::nullptr_t &gt;  = nullptr&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; value_type &gt; &gt; molpro::linalg::itsolv::svd_system </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reduce_to_rank</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs singular value decomposition and returns <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html" title="Stores a singular value and corresponding left and right singular vectors.">SVD</a> objects for singular values less than threshold, sorted in ascending order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">value_type</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nrows</td><td>number of rows in the matrix </td></tr>
    <tr><td class="paramname">ncols</td><td>number of columns in the matrix </td></tr>
    <tr><td class="paramname">m</td><td>row-wise data buffer for a matrix </td></tr>
    <tr><td class="paramname">threshold</td><td>singular values less than threshold will be returned </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab7117e36c19daa3142245f1493a5fb8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7117e36c19daa3142245f1493a5fb8f">&#9670;&nbsp;</a></span>svd_system&lt; value_type &gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::list&lt; <a class="el" href="structmolpro_1_1linalg_1_1itsolv_1_1SVD.html">SVD</a>&lt; value_type &gt; &gt; <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a7fcb72d6b1c715ed5d87f93aabf65581">molpro::linalg::itsolv::svd_system</a>&lt; value_type &gt; </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>nrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>ncols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmolpro_1_1linalg_1_1array_1_1span_1_1Span.html">array::Span</a>&lt; value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>hermitian</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reduce_to_rank</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ad9256532df6a4b245a3679328edc1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad9256532df6a4b245a3679328edc1d">&#9670;&nbsp;</a></span>wrap() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterableContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::wrap </td>
          <td>(</td>
          <td class="paramtype">const IterableContainer &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps references for each parameter in an iterable container that implements begin()/end() </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterableContainer</td><td>should have begin()/end() either as free or member functions </td></tr>
    <tr><td class="paramname">R</td><td>element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>parameters to wrap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of constant references to each element in parameters </dd></dl>

</div>
</div>
<a id="a7d650904c9a8f16d1ad6b8f2d3b766d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d650904c9a8f16d1ad6b8f2d3b766d5">&#9670;&nbsp;</a></span>wrap() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ForwardIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::wrap </td>
          <td>(</td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a begin and end iterators and returns a vector of references to each element. </p>

</div>
</div>
<a id="ae37643fbaca3b182e357855888611778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37643fbaca3b182e357855888611778">&#9670;&nbsp;</a></span>wrap() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IterableContainer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::wrap </td>
          <td>(</td>
          <td class="paramtype">IterableContainer &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wraps references for each parameter in an iterable container that implements begin()/end() </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">IterableContainer</td><td>should have begin()/end() either as free or member functions </td></tr>
    <tr><td class="paramname">R</td><td>element type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parameters</td><td>parameters to wrap </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>vector of references to each element in parameters </dd></dl>

</div>
</div>
<a id="a8e22e4990cb5176be5f6473bd0944ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e22e4990cb5176be5f6473bd0944ec0">&#9670;&nbsp;</a></span>wrap_arg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... S&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto molpro::linalg::itsolv::wrap_arg </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">S &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::enable_if_t&lt;std::conjunction_v&lt;std::is_same&lt;<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt;T&gt;, <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt;S&gt;&gt;...&gt;, <a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#ab44c7c7dfce88d39d260d1f5c7b70fab">VecRef</a>&lt;<a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html#a2541a0dfd2575a25a8d4976899b63e1d">decay_t</a>&lt;T&gt;&gt;&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a vector of reference wrappers with provided arguments. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacemolpro.html">molpro</a></li><li class="navelem"><a class="el" href="namespacemolpro_1_1linalg.html">linalg</a></li><li class="navelem"><a class="el" href="namespacemolpro_1_1linalg_1_1itsolv.html">itsolv</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
